using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Lemoo.UI.IconGenerator
{
    /// <summary>
    /// Source Generator for IconKind enum and related code.
    /// Generates type-safe icon enums from IconMetadata.json at compile time.
    /// </summary>
    [Generator]
    public class LemooIconGenerator : ISourceGenerator
    {
        private const string MetadataFileName = "IconMetadata.json";
        private const string GeneratedFileHeader = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by LemooIconGenerator.
//     DO NOT MODIFY THIS FILE MANUALLY - YOUR CHANGES WILL BE OVERWRITTEN
//
//     To regenerate: IconMetadata.json → LemooIconGenerator → IconKind.g.cs
//     Generated at: {0:yyyy-MM-dd HH:mm:ss}
// </auto-generated>
// ------------------------------------------------------------------------------

";

        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization needed for this generator
            // Register a callback to receive compilation notifications
            // context.RegisterForPostInitialization();
        }

        public void Execute(GeneratorExecutionContext context)
        {
            try
            {
                // Try to find IconMetadata.json in additional files
                var metadataFile = context.AdditionalFiles
                    .FirstOrDefault(f => f.Path.EndsWith(MetadataFileName, StringComparison.OrdinalIgnoreCase));

                if (metadataFile == null)
                {
                    ReportDiagnostic(context, DiagnosticSeverity.Warning,
                        "ICON001", $"IconMetadata.json not found in additional files. Icon generation skipped.");
                    return;
                }

                // Read and parse metadata
                var metadataText = context.AdditionalFiles.GetText(metadataFile);
                if (metadataText == null)
                {
                    ReportDiagnostic(context, DiagnosticSeverity.Error,
                        "ICON002", $"Failed to read {MetadataFileName}.");
                    return;
                }

                var metadata = ParseMetadata(metadataText.ToString());
                if (metadata == null)
                {
                    ReportDiagnostic(context, DiagnosticSeverity.Error,
                        "ICON003", $"Failed to parse {MetadataFileName}. Invalid JSON format.");
                    return;
                }

                // Generate source code
                var source = GenerateIconKindEnum(metadata);
                var sourceInfo = GenerateIconInfoExtensions(metadata);

                // Add generated sources
                context.AddSource("IconKind.g.cs", SourceText.From(source, Encoding.UTF8));
                context.AddSource("IconInfoExtensions.g.cs", SourceText.From(sourceInfo, Encoding.UTF8));

                ReportDiagnostic(context, DiagnosticSeverity.Info,
                    "ICON000", $"✓ Generated {metadata.Icons.Count} icon definitions.");
            }
            catch (Exception ex)
            {
                ReportDiagnostic(context, DiagnosticSeverity.Error,
                    "ICON999", $"Icon generator failed: {ex.Message}");
            }
        }

        private IconMetadata? ParseMetadata(string json)
        {
            try
            {
                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true,
                    ReadCommentHandling = JsonCommentHandling.Skip
                };

                return JsonSerializer.Deserialize<IconMetadata>(json, options);
            }
            catch
            {
                return null;
            }
        }

        private string GenerateIconKindEnum(IconMetadata metadata)
        {
            var sb = new StringBuilder();
            sb.AppendFormat(GeneratedFileHeader, DateTime.Now);

            // Usings
            sb.AppendLine("using System;");
            sb.AppendLine("using System.ComponentModel;");
            sb.AppendLine();
            sb.AppendLine("namespace Lemoo.UI.Models.Icons");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Icon type enumeration - auto-generated from {metadata.Font.Name}");
            sb.AppendLine("    /// Total icons: {0}", metadata.Icons.Count);
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public enum IconKind");
            sb.AppendLine("    {");

            // None value
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// No icon");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        [IconData(\"\\u0000\", \"None\", \"\")]");
            sb.AppendLine("        None,");

            // Group by category
            var groupedIcons = metadata.Icons
                .GroupBy(i => i.Category)
                .OrderBy(g => GetCategoryPriority(metadata, g.Key));

            foreach (var group in groupedIcons)
            {
                var categoryName = GetCategoryDisplayName(metadata, group.Key);
                sb.AppendLine();
                sb.AppendLine($"        #region {categoryName}");

                foreach (var icon in group.OrderBy(i => i.Name))
                {
                    // Skip if name contains invalid characters for enum
                    var sanitizedName = SanitizeIdentifier(icon.Name);
                    if (sanitizedName != icon.Name)
                    {
                        sb.AppendLine($"        // Note: '{icon.Name}' was sanitized to '{sanitizedName}'");
                    }

                    // XML documentation
                    sb.AppendLine("        /// <summary>");
                    if (!string.IsNullOrEmpty(icon.I18n?.Zh))
                    {
                        sb.AppendLine($"        /// {icon.I18n.Zh}");
                    }
                    else
                    {
                        sb.AppendLine($"        /// {icon.Name}");
                    }
                    sb.AppendLine("        /// </summary>");

                    // Attribute
                    var categoryDisplayName = GetCategoryDisplayName(metadata, icon.Category);
                    var attr = $"[IconData(\"{icon.UnicodeString}\", \"{icon.Name}\", \"{categoryDisplayName}\")]";

                    // Handle deprecated icons
                    if (icon.Deprecated)
                    {
                        sb.AppendLine($"        [Obsolete(\"This icon is deprecated\")]");
                    }

                    // Write the attribute and enum value
                    sb.AppendLine($"        {attr,-80} {sanitizedName},");
                }

                sb.AppendLine("        #endregion");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private string GenerateIconInfoExtensions(IconMetadata metadata)
        {
            var sb = new StringBuilder();
            sb.AppendFormat(GeneratedFileHeader, DateTime.Now);

            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine();
            sb.AppendLine("namespace Lemoo.UI.Models.Icons");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Extension methods for IconKind enum - auto-generated");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static partial class IconKindExtensions");
            sb.AppendLine("    {");
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets all available icon kinds");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static IconKind[] GetAllIcons()");
            sb.AppendLine("        {");
            sb.AppendLine("            return new[]");
            sb.AppendLine("            {");

            foreach (var icon in metadata.Icons.OrderBy(i => i.Name))
            {
                var sanitizedName = SanitizeIdentifier(icon.Name);
                sb.AppendLine($"                IconKind.{sanitizedName},");
            }

            sb.AppendLine("            };");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets icon metadata by kind");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static IconMetadataItem? GetMetadata(this IconKind kind)");
            sb.AppendLine("        {");
            sb.AppendLine("            return kind switch");
            sb.AppendLine("            {");

            foreach (var icon in metadata.Icons.OrderBy(i => i.Name))
            {
                var sanitizedName = SanitizeIdentifier(icon.Name);
                var keywords = string.Join(", ", icon.Keywords.Select(k => $"\"{k}\""));
                sb.AppendLine($"                IconKind.{sanitizedName} => new IconMetadataItem");
                sb.AppendLine($"                {{");
                sb.AppendLine($"                    Kind = IconKind.{sanitizedName},");
                sb.AppendLine($"                    Glyph = \"{icon.Glyph}\",");
                sb.AppendLine($"                    Unicode = \"{icon.Unicode}\",");
                sb.AppendLine($"                    UnicodeString = \"{icon.UnicodeString}\",");
                sb.AppendLine($"                    Name = \"{icon.Name}\",");
                sb.AppendLine($"                    Category = \"{icon.Category}\",");
                sb.AppendLine($"                    Keywords = new[] {{ {keywords} }},");
                if (!string.IsNullOrEmpty(icon.I18n?.En))
                    sb.AppendLine($"                    NameEn = \"{icon.I18n.En}\",");
                if (!string.IsNullOrEmpty(icon.I18n?.Zh))
                    sb.AppendLine($"                    NameZh = \"{icon.I18n.Zh}\",");
                sb.AppendLine($"                    Deprecated = {(icon.Deprecated ? "true" : "false")}");
                sb.AppendLine($"                }},");
            }

            sb.AppendLine("                _ => null");
            sb.AppendLine("            };");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Icon metadata item - auto-generated");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public sealed class IconMetadataItem");
            sb.AppendLine("    {");
            sb.AppendLine("        public IconKind Kind { get; init; }");
            sb.AppendLine("        public string Glyph { get; init; } = string.Empty;");
            sb.AppendLine("        public string Unicode { get; init; } = string.Empty;");
            sb.AppendLine("        public string UnicodeString { get; init; } = string.Empty;");
            sb.AppendLine("        public string Name { get; init; } = string.Empty;");
            sb.AppendLine("        public string Category { get; init; } = string.Empty;");
            sb.AppendLine("        public string[] Keywords { get; init; } = Array.Empty<string>();");
            sb.AppendLine("        public string NameEn { get; init; } = string.Empty;");
            sb.AppendLine("        public string NameZh { get; init; } = string.Empty;");
            sb.AppendLine("        public bool Deprecated { get; init; }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private int GetCategoryPriority(IconMetadata metadata, string categoryKey)
        {
            var category = metadata.Categories.FirstOrDefault(c => c.Key == categoryKey);
            return category?.Priority ?? 999;
        }

        private string GetCategoryDisplayName(IconMetadata metadata, string categoryKey)
        {
            var category = metadata.Categories.FirstOrDefault(c => c.Key == categoryKey);
            return category?.NameZh ?? categoryKey;
        }

        private string SanitizeIdentifier(string name)
        {
            // Remove invalid characters
            var sanitized = new StringBuilder();
            for (int i = 0; i < name.Length; i++)
            {
                var c = name[i];
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    sanitized.Append(c);
                }
                else if (i > 0 && char.IsLetterOrDigit(name[i - 1]))
                {
                    sanitized.Append('_');
                }
            }

            // Ensure it doesn't start with a digit
            if (sanitized.Length > 0 && char.IsDigit(sanitized[0]))
            {
                sanitized.Insert(0, '_');
            }

            var result = sanitized.ToString();
            if (string.IsNullOrEmpty(result))
            {
                return "_";
            }

            // Check for C# keywords
            var keywords = new[] { "abstract", "as", "base", "bool", "break", "byte", "case", "catch",
                "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do",
                "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed",
                "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal",
                "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override",
                "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
                "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw",
                "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using",
                "virtual", "void", "volatile", "while" };

            if (Array.IndexOf(keywords, result.ToLower()) >= 0)
            {
                return "@" + result;
            }

            return result;
        }

        private void ReportDiagnostic(GeneratorExecutionContext context, DiagnosticSeverity severity,
            string id, string message)
        {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    id,
                    "Icon Generator",
                    message,
                    "IconGeneration",
                    severity,
                    true),
                Location.None);

            context.ReportDiagnostic(diagnostic);
        }

        // Data models for JSON deserialization
        private class IconMetadata
        {
            [JsonPropertyName("font")]
            public FontInfo Font { get; set; } = new();

            [JsonPropertyName("categories")]
            public List<CategoryInfo> Categories { get; set; } = new();

            [JsonPropertyName("icons")]
            public List<IconInfoItem> Icons { get; set; } = new();
        }

        private class FontInfo
        {
            [JsonPropertyName("name")]
            public string Name { get; set; } = string.Empty;

            [JsonPropertyName("version")]
            public string Version { get; set; } = string.Empty;

            [JsonPropertyName("copyright")]
            public string? Copyright { get; set; }
        }

        private class CategoryInfo
        {
            [JsonPropertyName("key")]
            public string Key { get; set; } = string.Empty;

            [JsonPropertyName("name")]
            public string Name { get; set; } = string.Empty;

            [JsonPropertyName("name_zh")]
            public string NameZh { get; set; } = string.Empty;

            [JsonPropertyName("priority")]
            public int Priority { get; set; }
        }

        private class IconInfoItem
        {
            [JsonPropertyName("glyph")]
            public string Glyph { get; set; } = string.Empty;

            [JsonPropertyName("unicode")]
            public string Unicode { get; set; } = string.Empty;

            [JsonPropertyName("unicode_string")]
            public string UnicodeString { get; set; } = string.Empty;

            [JsonPropertyName("name")]
            public string Name { get; set; } = string.Empty;

            [JsonPropertyName("category")]
            public string Category { get; set; } = string.Empty;

            [JsonPropertyName("keywords")]
            public List<string> Keywords { get; set; } = new();

            [JsonPropertyName("i18n")]
            public I18nInfo? I18n { get; set; }

            [JsonPropertyName("aliases")]
            public List<string>? Aliases { get; set; }

            [JsonPropertyName("deprecated")]
            public bool Deprecated { get; set; }
        }

        private class I18nInfo
        {
            [JsonPropertyName("en")]
            public string? En { get; set; }

            [JsonPropertyName("zh")]
            public string? Zh { get; set; }
        }
    }
}
