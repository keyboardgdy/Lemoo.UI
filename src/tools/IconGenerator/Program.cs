using System.Text;
using System.Text.Json;

namespace IconGenerator;

/// <summary>
/// 图标元数据模型
/// </summary>
internal class IconMetadata
{
    public FontInfo Font { get; set; } = new();
    public List<CategoryInfo> Categories { get; set; } = new();
    public List<IconInfoItem> Icons { get; set; } = new();
}

internal class FontInfo
{
    public string Name { get; set; } = string.Empty;
    public string Version { get; set; } = string.Empty;
}

internal class CategoryInfo
{
    public string Key { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string NameZh { get; set; } = string.Empty;
    public int Priority { get; set; }
}

internal class IconInfoItem
{
    public string Glyph { get; set; } = string.Empty;
    public string Unicode { get; set; } = string.Empty;
    public string UnicodeString { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty;
    public List<string> Keywords { get; set; } = new();
    public I18nInfo? I18n { get; set; }
    public bool Deprecated { get; set; }
}

internal class I18nInfo
{
    public string? En { get; set; }
    public string? Zh { get; set; }
}

class Program
{
    static void Main(string[] args)
    {
        var projectRoot = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "../../../../../../"));
        var metadataPath = Path.Combine(projectRoot, "src/UI/Lemoo.UI/Models/Icons/IconMetadata.json");
        var outputPath = Path.Combine(projectRoot, "src/UI/Lemoo.UI/Models/Icons/IconKind.cs");

        Console.WriteLine($"Reading metadata from: {metadataPath}");

        if (!File.Exists(metadataPath))
        {
            Console.Error.WriteLine($"IconMetadata.json not found at: {metadataPath}");
            Environment.Exit(1);
            return;
        }

        var json = File.ReadAllText(metadataPath);
        var metadata = JsonSerializer.Deserialize<IconMetadata>(json, new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        });

        if (metadata == null || metadata.Icons == null)
        {
            Console.Error.WriteLine("Failed to parse IconMetadata.json");
            Environment.Exit(1);
            return;
        }

        Console.WriteLine($"Generating {metadata.Icons.Count} icons to: {outputPath}");

        using var writer = new StreamWriter(outputPath, false, Encoding.UTF8);

        // Write header
        writer.WriteLine("// ------------------------------------------------------------------------------");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("//     This code was generated by IconGenerator program.");
        writer.WriteLine($"//     Generated at: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine("// ------------------------------------------------------------------------------");
        writer.WriteLine();
        writer.WriteLine("using System;");
        writer.WriteLine("using System.ComponentModel;");
        writer.WriteLine();
        writer.WriteLine("namespace Lemoo.UI.Models.Icons");
        writer.WriteLine("{");
        writer.WriteLine("    /// <summary>");
        writer.WriteLine("    /// Icon type enumeration - auto-generated from IconMetadata.json");
        writer.WriteLine("    /// </summary>");
        writer.WriteLine("    public enum IconKind");
        writer.WriteLine("    {");
        writer.WriteLine("        /// <summary>");
        writer.WriteLine("        /// No icon");
        writer.WriteLine("        /// </summary>");
        writer.WriteLine("        [IconData(\"\\u0000\", \"None\", \"\")]");
        writer.WriteLine("        None,");

        // Group by category
        var groupedIcons = metadata.Icons
            .GroupBy(i => i.Category)
            .OrderBy(g => GetCategoryPriority(metadata, g.Key));

        foreach (var group in groupedIcons)
        {
            var categoryName = GetCategoryDisplayName(metadata, group.Key);
            writer.WriteLine();
            writer.WriteLine($"        #region {categoryName}");
            writer.WriteLine();

            foreach (var icon in group.OrderBy(i => i.Name))
            {
                var sanitizedName = SanitizeIdentifier(icon.Name);
                var categoryDisplayName = GetCategoryDisplayName(metadata, icon.Category);
                var chineseName = (!string.IsNullOrEmpty(icon.I18n?.Zh) ? icon.I18n.Zh : icon.Name) ?? icon.Name;

                writer.WriteLine("        /// <summary>");
                writer.WriteLine($"        /// {chineseName}");
                writer.WriteLine("        /// </summary>");

                if (icon.Deprecated)
                {
                    writer.WriteLine("        [Obsolete(\"This icon is deprecated\")]");
                }

                // Escape the unicode string properly for C#
                var escapedUnicode = icon.UnicodeString.Replace("\\", "\\\\");
                writer.WriteLine($"        [IconData(\"{escapedUnicode}\", \"{icon.Name}\", \"{categoryDisplayName}\")]");
                writer.WriteLine($"        {sanitizedName},");
            }

            writer.WriteLine();
            writer.WriteLine("        #endregion");
        }

        writer.WriteLine("    }");
        writer.WriteLine("}");

        Console.WriteLine("✓ Generation complete!");
        Console.WriteLine($"  Total icons: {metadata.Icons.Count}");
        Console.WriteLine($"  Categories: {groupedIcons.Count()}");
    }

    static int GetCategoryPriority(IconMetadata metadata, string categoryKey)
    {
        var category = metadata.Categories?.FirstOrDefault(c => c.Key == categoryKey);
        return category?.Priority ?? 999;
    }

    static string GetCategoryDisplayName(IconMetadata metadata, string categoryKey)
    {
        var category = metadata.Categories?.FirstOrDefault(c => c.Key == categoryKey);
        return category?.NameZh ?? categoryKey;
    }

    static string SanitizeIdentifier(string name)
    {
        var sanitized = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsLetterOrDigit(c) || c == '_')
            {
                sanitized.Append(c);
            }
            else if (i > 0 && char.IsLetterOrDigit(name[i - 1]))
            {
                sanitized.Append('_');
            }
        }

        var result = sanitized.ToString();
        if (string.IsNullOrEmpty(result))
        {
            return "_";
        }

        if (char.IsDigit(result[0]))
        {
            return "_" + result;
        }

        var keywords = new[] { "abstract", "as", "base", "bool", "break", "byte", "case", "catch",
            "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do",
            "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed",
            "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal",
            "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override",
            "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
            "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw",
            "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using",
            "virtual", "void", "volatile", "while" };

        if (Array.IndexOf(keywords, result.ToLower()) >= 0)
        {
            return "@" + result;
        }

        return result;
    }
}
