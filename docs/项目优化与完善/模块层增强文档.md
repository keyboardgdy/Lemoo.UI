# 模块层架构增强文档

## 概述

本次更新修复了模块层的多个架构问题，增强了模块化能力。

## 主要改进

### 1. 程序集卸载支持

**问题**: .NET 中程序集默认无法卸载，导致模块热重载时内存泄漏

**解决方案**: 实现了基于 `AssemblyLoadContext` 的可卸载模块加载

**新文件**:
- `ModuleLoadContext.cs` - 模块程序集加载上下文

**使用方式**:
```csharp
// 卸载单个模块
await moduleLoader.UnloadModuleAsync("TaskManager");

// 卸载所有模块
await moduleLoader.UnloadAllModulesAsync();
```

### 2. 模块版本兼容性检查

**问题**: 模块依赖只检查名称，不检查版本范围

**解决方案**: 支持语义化版本范围检查

**新文件**:
- `ModuleDependency.cs` - 模块依赖描述和版本范围解析

**使用方式**:
```csharp
public class MyModule : ModuleBase
{
    public override IReadOnlyList<ModuleDependency> DependencyModules => new[]
    {
        new ModuleDependency("TaskManager", ">=1.0.0"),
        new ModuleDependency("UserService", "^2.0.0"),
        new ModuleDependency("Logger", "~1.5.0", isRequired: false)
    };
}
```

**支持的版本范围语法**:
- `1.0.0` - 精确版本
- `>=1.0.0` - 大于等于
- `>1.0.0` - 大于
- `<=1.0.0` - 小于等于
- `<1.0.0` - 小于
- `1.0.0 - 2.0.0` - 范围
- `^1.0.0` - 兼容版本 (>=1.0.0 && <2.0.0)
- `~1.0.0` - 补丁版本 (>=1.0.0 && <1.1.0)

### 3. 模块服务容器隔离

**问题**: 共享 DI 容器导致服务冲突

**解决方案**: 实现模块级别的服务容器隔离

**新文件**:
- `IModuleServiceContainer.cs` - 模块服务容器接口和实现

**使用方式**:
```csharp
// 创建模块服务容器
var container = new ModuleServiceContainer("MyModule");

// 导出服务
container.ExportService("IDataService", new DataService());

// 导入服务
container.ImportService("ILogger", logger);

// 构建服务提供者
var serviceProvider = container.BuildServiceProvider();
```

### 4. 模块间通信契约

**问题**: 跨模块命令/查询依赖直接类型引用

**解决方案**: 定义模块间通信的显式契约

**新文件**:
- `IModuleContract.cs` - 模块契约接口和注册表
- `ITaskServiceContract.cs` - 任务服务契约示例
- `TaskServiceContractAdapter.cs` - 契约适配器示例

**使用方式**:

**1. 定义契约接口**:
```csharp
[ModuleContract("TaskService", "任务管理服务契约")]
public interface ITaskServiceContract : IModuleContract
{
    string ContractName => "TaskService";
    string Version => "1.0.0";
    string Description => "提供任务管理相关的服务";
    string ProviderModule => "TaskManager";

    Task<IReadOnlyList<TaskDto>> GetAllTasksAsync(CancellationToken cancellationToken = default);
    // ... 其他方法
}
```

**2. 实现契约适配器**:
```csharp
public class TaskServiceContractAdapter : ITaskServiceContract
{
    private readonly ISender _mediator;

    public TaskServiceContractAdapter(ISender mediator)
    {
        _mediator = mediator;
    }

    public async Task<IReadOnlyList<TaskDto>> GetAllTasksAsync(CancellationToken cancellationToken = default)
    {
        var query = new GetAllTasksQuery();
        var result = await _mediator.Send(query, cancellationToken);
        return result.Value ?? Array.Empty<TaskDto>();
    }
}
```

**3. 在模块中注册契约**:
```csharp
public override void ConfigureServices(IServiceCollection services, IConfiguration configuration)
{
    // 注册契约适配器
    services.AddSingleton<ITaskServiceContract, TaskServiceContractAdapter>();

    // 其他服务注册...
}
```

**4. 在其他模块中使用契约**:
```csharp
public class OtherModuleService
{
    private readonly ITaskServiceContract _taskService;

    public OtherModuleService(ITaskServiceContract taskService)
    {
        _taskService = taskService;
    }

    public async Task DoSomething()
    {
        var tasks = await _taskService.GetAllTasksAsync();
        // 处理任务...
    }
}
```

### 5. 模块生命周期管理

**新文件**:
- `IModuleLifecycleManager.cs` - 模块生命周期管理器

**使用方式**:
```csharp
// 获取模块状态
var state = await lifecycleManager.GetModuleStateAsync("TaskManager");

// 启动模块
var result = await lifecycleManager.StartModuleAsync("TaskManager", serviceProvider);

// 停止模块
var result = await lifecycleManager.StopModuleAsync("TaskManager", serviceProvider);

// 重启模块
var result = await lifecycleManager.RestartModuleAsync("TaskManager", serviceProvider);
```

## 更新的接口

### IModule 接口

新增属性:
```csharp
// 支持版本范围的依赖
IReadOnlyList<ModuleDependency> DependencyModules { get; }

// 导出的服务类型
IReadOnlyList<string> ExportedServices { get; }

// 导入的服务类型
IReadOnlyList<string> ImportedServices { get; }
```

### ModuleMetadata 类

新增属性:
```csharp
public IReadOnlyList<string> ExportedServices { get; set; }
public IReadOnlyList<string> ImportedServices { get; set; }
public ModuleState State { get; set; }
```

### IModuleLoader 接口

新增方法:
```csharp
Task<bool> UnloadModuleAsync(string moduleName, TimeSpan timeout = default);
Task UnloadAllModulesAsync(TimeSpan timeout = default);
```

## 迁移指南

### 对于现有模块

1. **兼容性**: 现有模块继续使用 `Dependencies` 属性，无需修改

2. **可选升级**: 要使用版本范围检查，添加 `DependencyModules` 属性:
```csharp
public override IReadOnlyList<ModuleDependency> DependencyModules => new[]
{
    new ModuleDependency("TaskManager", ">=1.0.0")
};
```

### 对于 UI 模块

要解耦 UI 与后端模块:

1. 在后端模块定义契约接口
2. 实现契约适配器
3. 在 UI 模块通过契约接口访问服务

**示例**:
```csharp
// UI 模块中不再直接引用 DTO
// 而是通过契约接口访问
public class TaskListViewModel
{
    private readonly ITaskServiceContract _taskService;

    public TaskListViewModel(ITaskServiceContract taskService)
    {
        _taskService = taskService;
    }

    public async Task LoadTasksAsync()
    {
        var tasks = await _taskService.GetAllTasksAsync();
        // 绑定到 UI
    }
}
```

## 配置

在 `appsettings.json` 中配置模块:

```json
{
  "Lemoo": {
    "Modules": {
      "Enabled": [ "TaskManager", "UserService", "*" ],
      "Path": "./Modules"
    }
  }
}
```

## 最佳实践

1. **使用契约接口**: 在模块间通信时使用契约接口而非直接类型引用
2. **版本管理**: 使用语义化版本号，并在依赖中指定版本范围
3. **服务导出/导入**: 明确声明模块导出和导入的服务
4. **生命周期管理**: 在模块启动/停止时正确初始化和清理资源
5. **契约版本控制**: 当契约接口变化时，更新版本号

## 注意事项

1. **程序集卸载限制**: 程序集卸载需要等待 GC 回收，可能需要一些时间
2. **契约兼容性**: 契约接口变化时需要考虑向后兼容性
3. **服务隔离**: 当前实现仍使用共享 DI 容器，模块服务容器隔离需要手动管理
