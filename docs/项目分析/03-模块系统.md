# Lemoo.UI 模块系统

## 模块系统概述

Lemoo.UI 的模块系统是一个基于插件式架构的模块化框架。每个模块都是独立的程序集，可以动态加载、卸载，支持模块间的依赖管理。

## 核心组件

### 1. 模块接口 (IModule)

```csharp
public interface IModule
{
    /// <summary>
    /// 模块名称
    /// </summary>
    string Name { get; }

    /// <summary>
    /// 模块版本
    /// </summary>
    string Version { get; }

    /// <summary>
    /// 模块描述
    /// </summary>
    string Description { get; }

    /// <summary>
    /// 模块依赖
    /// </summary>
    IReadOnlyList<string> Dependencies { get; }

    /// <summary>
    /// 前置配置（在所有模块配置之前调用）
    /// </summary>
    void PreConfigureServices(
        IServiceCollection services,
        IConfiguration configuration,
        IHostEnvironment environment);

    /// <summary>
    /// 配置服务（模块主要配置点）
    /// </summary>
    void ConfigureServices(
        IServiceCollection services,
        IConfiguration configuration,
        IHostEnvironment environment);

    /// <summary>
    /// 后置配置（在所有模块配置之后调用）
    /// </summary>
    void PostConfigureServices(
        IServiceCollection services,
        IConfiguration configuration,
        IHostEnvironment environment);

    /// <summary>
    /// 配置数据库上下文
    /// </summary>
    void ConfigureDbContext(
        IServiceCollection services,
        IConfiguration configuration,
        IHostEnvironment environment);

    /// <summary>
    /// 配置实体模型
    /// </summary>
    void ConfigureDbContext(ModelBuilder modelBuilder);

    /// <summary>
    /// 应用程序启动前
    /// </summary>
    Task OnApplicationStartingAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// 应用程序启动后
    /// </summary>
    Task OnApplicationStartedAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// 应用程序停止前
    /// </summary>
    Task OnApplicationStoppingAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// 应用程序停止后
    /// </summary>
    Task OnApplicationStoppedAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default);
}
```

### 2. 模块基类 (ModuleBase)

```csharp
public abstract class ModuleBase : IModule
{
    public abstract string Name { get; }
    public abstract string Version { get; }
    public abstract string Description { get; }

    public virtual IReadOnlyList<string> Dependencies => Array.Empty<string>();

    public virtual void PreConfigureServices(...) { }
    public abstract void ConfigureServices(...);
    public virtual void PostConfigureServices(...) { }

    public abstract void ConfigureDbContext(...);
    public virtual void ConfigureDbContext(ModelBuilder modelBuilder) { }

    public virtual Task OnApplicationStartingAsync(...) => Task.CompletedTask;
    public virtual Task OnApplicationStartedAsync(...) => Task.CompletedTask;
    public virtual Task OnApplicationStoppingAsync(...) => Task.CompletedTask;
    public virtual Task OnApplicationStoppedAsync(...) => Task.CompletedTask;
}
```

### 3. 模块加载器 (ModuleLoader)

```csharp
public class ModuleLoader : IModuleLoader
{
    /// <summary>
    /// 加载模块
    /// </summary>
    public Task<ModuleLoadResult> LoadModulesAsync(
        string modulePath,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// 验证模块依赖
    /// </summary>
    private void ValidateDependencies(IModule[] modules);

    /// <summary>
    /// 拓扑排序（确保依赖顺序）
    /// </summary>
    private IModule[] TopologicalSort(IModule[] modules);

    /// <summary>
    /// 检测循环依赖
    /// </summary>
    private void DetectCircularDependencies(IModule[] modules);
}
```

## 模块加载流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    1. 模块发现 (Discovery)                       │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ • 扫描 ./Modules 目录                                     │  │
│  │ • 从 AppDomain 发现已加载程序集                            │  │
│  │ • 查找实现 IModule 的类型                                 │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    2. 模块实例化 (Instantiation)                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ • 使用反射创建模块实例                                     │  │
│  │ • 验证模块元数据（名称、版本）                             │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    3. 依赖验证 (Validation)                      │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ • 验证依赖的模块是否存在                                   │  │
│  │ • 检测循环依赖                                             │  │
│  │ • 版本兼容性检查                                           │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    4. 拓扑排序 (Topological Sort)                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ • 根据依赖关系排序                                         │  │
│  │ • 确保依赖模块先于被依赖模块加载                           │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    5. 前置配置 (Pre-Configure)                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ • 按依赖顺序调用 PreConfigureServices                      │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    6. 服务配置 (Configure Services)              │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ • 注册 DbContext                                           │  │
│  │ • 注册工作单元和仓储                                       │  │
│  │ • 注册 MediatR 处理器                                      │  │
│  │ •注册验证器                                                │  │
│  │ • 注册业务服务                                             │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    7. 后置配置 (Post-Configure)                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ • 按依赖逆序调用 PostConfigureServices                     │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    8. 模块启动 (Startup)                         │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ • 调用 OnApplicationStartingAsync                          │  │
│  │ • 应用程序启动                                             │  │
│  │ • 调用 OnApplicationStartedAsync                           │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
                         模块就绪
```

## 模块开发指南

### 创建新模块

#### 1. 创建项目结构

```
Lemoo.Modules.YourModule/
├── Domain/
│   ├── Entities/
│   │   └── YourEntity.cs
│   ├── ValueObjects/
│   └── DomainEvents/
├── Application/
│   ├── Commands/
│   ├── Queries/
│   ├── Handlers/
│   ├── DTOs/
│   └── Validators/
├── Infrastructure/
│   ├── Persistence/
│   │   ├── YourModuleDbContext.cs
│   │   └── Configurations/
│   └── Repositories/
├── YourModule.cs
└── YourModule.csproj
```

#### 2. 定义模块类

```csharp
public class YourModule : ModuleBase
{
    public override string Name => "YourModule";
    public override string Version => "1.0.0";
    public override string Description => "Your module description";

    public override IReadOnlyList<string> Dependencies => new[]
    {
        "TaskManager"  // 依赖其他模块
    };

    public override void ConfigureServices(
        IServiceCollection services,
        IConfiguration configuration,
        IHostEnvironment environment)
    {
        // 1. 注册 DbContext
        services.AddDbContext<YourModuleDbContext>((provider, options) =>
        {
            var connectionString = configuration.GetConnectionString("DefaultConnection");
            options.UseSqlServer(connectionString);
        });

        // 2. 注册工作单元
        services.AddScoped<IUnitOfWork>(provider =>
        {
            var dbContext = provider.GetRequiredService<YourModuleDbContext>();
            return new UnitOfWork(dbContext);
        });

        // 3. 注册仓储
        services.AddScoped<IYourEntityRepository, YourEntityRepository>();

        // 4. 注册 MediatR
        services.AddMediatR(cfg =>
        {
            cfg.RegisterServicesFromAssembly(typeof(YourModule).Assembly);
        });

        // 5. 注册验证器
        services.AddValidatorsFromAssembly(typeof(YourModule).Assembly);

        // 6. 注册 CQRS 管道行为
        services.AddCqrsPipelineBehaviors();

        // 7. 注册业务服务
        services.AddScoped<IYourService, YourService>();
    }

    public override void ConfigureDbContext(
        IServiceCollection services,
        IConfiguration configuration,
        IHostEnvironment environment)
    {
        // 配置数据库连接等
    }

    public override void ConfigureDbContext(ModelBuilder modelBuilder)
    {
        // 配置实体映射
        modelBuilder.ApplyConfiguration(new YourEntityConfiguration());
    }

    public override async Task OnApplicationStartedAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default)
    {
        // 模块初始化逻辑
        // 例如：数据库迁移、种子数据等
        await using var scope = serviceProvider.CreateAsyncScope();
        var dbContext = scope.ServiceProvider.GetRequiredService<YourModuleDbContext>();
        await dbContext.Database.EnsureCreatedAsync(cancellationToken);
    }
}
```

#### 3. 定义聚合根

```csharp
public class YourEntity : AggregateRoot<Guid>
{
    public string Name { get; private set; }
    public string Description { get; private set; }

    private YourEntity() { }

    public static Result<YourEntity> Create(
        string name,
        string description)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return Result.Failure<YourEntity>("Name is required");
        }

        var entity = new YourEntity
        {
            Id = Guid.NewGuid(),
            Name = name,
            Description = description
        };

        entity.AddDomainEvent(new YourEntityCreatedEvent(entity.Id));

        return Result.Success(entity);
    }

    public Result Update(string name, string description)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return Result.Failure("Name is required");
        }

        Name = name;
        Description = description;
        UpdatedAt = DateTime.UtcNow;

        AddDomainEvent(new YourEntityUpdatedEvent(Id));

        return Result.Success();
    }
}
```

#### 4. 定义命令和处理器

```csharp
// 命令
public record CreateYourEntityCommand(
    string Name,
    string Description) : ICommand<Result<Guid>>;

// 验证器
public class CreateYourEntityCommandValidator : AbstractValidator<CreateYourEntityCommand>
{
    public CreateYourEntityCommandValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty()
            .MaximumLength(100);

        RuleFor(x => x.Description)
            .MaximumLength(500);
    }
}

// 处理器
public class CreateYourEntityCommandHandler : ICommandHandler<CreateYourEntityCommand, Result<Guid>>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IYourEntityRepository _repository;

    public CreateYourEntityCommandHandler(
        IUnitOfWork unitOfWork,
        IYourEntityRepository repository)
    {
        _unitOfWork = unitOfWork;
        _repository = repository;
    }

    public async Task<Result<Guid>> Handle(
        CreateYourEntityCommand request,
        CancellationToken cancellationToken)
    {
        // 创建实体
        var result = YourEntity.Create(request.Name, request.Description);

        if (result.IsFailure)
        {
            return Result.Failure<Guid>(result.Error);
        }

        var entity = result.Value;

        // 保存到仓储
        await _repository.AddAsync(entity, cancellationToken);
        await _unitOfWork.SaveChangesAsync(cancellationToken);

        return Result.Success(entity.Id);
    }
}
```

#### 5. 定义查询和处理器

```csharp
// 查询
public record GetYourEntityQuery(Guid Id) : IQuery<Result<YourEntityDto>>;

// DTO
public record YourEntityDto(
    Guid Id,
    string Name,
    string Description,
    DateTime CreatedAt);

// 处理器
public class GetYourEntityQueryHandler : IQueryHandler<GetYourEntityQuery, Result<YourEntityDto>>
{
    private readonly IYourEntityRepository _repository;

    public GetYourEntityQueryHandler(IYourEntityRepository repository)
    {
        _repository = repository;
    }

    public async Task<Result<YourEntityDto>> Handle(
        GetYourEntityQuery request,
        CancellationToken cancellationToken)
    {
        var entity = await _repository.GetByIdAsync(request.Id, cancellationToken);

        if (entity is null)
        {
            return Result.Failure<YourEntityDto>("Entity not found");
        }

        var dto = new YourEntityDto(
            entity.Id,
            entity.Name,
            entity.Description,
            entity.CreatedAt);

        return Result.Success(dto);
    }
}
```

## 模块间通信

### 1. 通过 MediatR 通信

```csharp
// 模块 A 调用模块 B 的命令
public class ModuleAService
{
    private readonly ISender _mediator;

    public ModuleAService(ISender mediator)
    {
        _mediator = mediator;
    }

    public async Task<Result> CallModuleBCommand()
    {
        var command = new ModuleBCommand(...);
        return await _mediator.Send(command);
    }
}
```

### 2. 通过领域事件通信

```csharp
// 模块 A 发布事件
public class ModuleAEntity : AggregateRoot<Guid>
{
    public void DoSomething()
    {
        // 业务逻辑
        AddDomainEvent(new ModuleAEvent(Id));
    }
}

// 模块 B 订阅事件
public class ModuleAEventHandler : IDomainEventHandler<ModuleAEvent>
{
    public async Task Handle(ModuleAEvent notification, CancellationToken cancellationToken)
    {
        // 处理事件
    }
}
```

## 模块依赖管理

### 依赖声明

```csharp
public override IReadOnlyList<string> Dependencies => new[]
{
    "CoreModule",      // 核心模块
    "TaskManager",     // 任务管理模块
    "UserManagement"   // 用户管理模块
};
```

### 依赖规则

1. **无循环依赖**: 模块 A 不能直接或间接依赖自己
2. **传递依赖**: 如果 A 依赖 B，B 依赖 C，则 A 自动获得对 C 的访问权
3. **加载顺序**: 依赖模块先于被依赖模块加载
4. **版本兼容**: 建议使用语义化版本控制

## 模块生命周期钩子

```csharp
public class YourModule : ModuleBase
{
    // 应用启动前（可用于准备工作）
    public override async Task OnApplicationStartingAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default)
    {
        var logger = serviceProvider.GetRequiredService<ILogger<YourModule>>();
        logger.LogInformation("YourModule is starting...");
    }

    // 应用启动后（可用于初始化数据）
    public override async Task OnApplicationStartedAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default)
    {
        var logger = serviceProvider.GetRequiredService<ILogger<YourModule>>();
        logger.LogInformation("YourModule started successfully!");

        // 执行数据库迁移
        await using var scope = serviceProvider.CreateAsyncScope();
        var dbContext = scope.ServiceProvider.GetRequiredService<YourModuleDbContext>();
        await dbContext.Database.MigrateAsync(cancellationToken);
    }

    // 应用停止前（可用于清理工作）
    public override async Task OnApplicationStoppingAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default)
    {
        var logger = serviceProvider.GetRequiredService<ILogger<YourModule>>();
        logger.LogInformation("YourModule is stopping...");
    }

    // 应用停止后
    public override async Task OnApplicationStoppedAsync(
        IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default)
    {
        var logger = serviceProvider.GetRequiredService<ILogger<YourModule>>();
        logger.LogInformation("YourModule stopped.");
    }
}
```

## 模块配置

### appsettings.json

```json
{
  "Modules": {
    "TaskManager": {
      "Enabled": true,
      "ConnectionString": "Data Source=taskmanager.db"
    },
    "YourModule": {
      "Enabled": true,
      "Setting1": "value1",
      "Setting2": 42
    }
  }
}
```

### 读取模块配置

```csharp
public override void ConfigureServices(
    IServiceCollection services,
    IConfiguration configuration,
    IHostEnvironment environment)
{
    // 读取模块配置
    var moduleConfig = configuration.GetSection($"Modules:{Name}");
    var setting1 = moduleConfig["Setting1"];
    var setting2 = moduleConfig.GetValue<int>("Setting2");

    // 注册配置选项
    services.Configure<YourModuleOptions>(
        configuration.GetSection($"Modules:{Name}"));
}
```
