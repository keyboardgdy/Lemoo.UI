# Lemoo 模块集成标准文档

## 目录

1. [架构概述](#架构概述)
2. [后端模块创建标准](#后端模块创建标准)
3. [UI模块创建标准](#ui模块创建标准)
4. [模块集成流程](#模块集成流程)
5. [命名约定](#命名约定)
6. [配置要求](#配置要求)
7. [依赖管理](#依赖管理)
8. [最佳实践](#最佳实践)
9. [常见问题](#常见问题)

---

## 架构概述

Lemoo 采用模块化插件架构，支持动态加载和集成后端业务模块和UI模块。架构特点：

- **后端模块**：独立的业务功能单元，包含领域模型、应用逻辑和数据库上下文
- **UI模块**：与后端模块对应的用户界面，提供页面和导航项
- **自动发现**：运行时自动发现和加载模块，无需手动注册
- **依赖管理**：自动处理模块依赖关系，确保正确加载顺序
- **生命周期管理**：完整的模块生命周期支持（启动、运行、停止）

### 模块类型

1. **后端模块** (`Lemoo.Modules.{ModuleName}`)
   - 实现 `IModule` 接口或继承 `ModuleBase`
   - 包含 Domain、Application、Infrastructure 三层
   - 独立的数据库上下文

2. **UI模块** (`Lemoo.Modules.{ModuleName}.UI`)
   - 实现 `IModuleUI` 接口
   - 提供 WPF 页面和视图模型
   - 配置导航项

---

## 后端模块创建标准

### 1. 项目结构

```
Lemoo.Modules.YourModule/
├── Domain/                      # 领域层
│   ├── Entities/                # 实体
│   │   └── YourEntity.cs
│   ├── ValueObjects/            # 值对象
│   ├── DomainEvents/            # 领域事件
│   │   └── YourEntityCreatedEvent.cs
│   └── Interfaces/             # 领域接口
│       └── IYourEntityRepository.cs
├── Application/                 # 应用层
│   ├── Commands/               # 命令
│   │   ├── CreateYourEntityCommand.cs
│   │   └── UpdateYourEntityCommand.cs
│   ├── Queries/                # 查询
│   │   ├── GetYourEntityQuery.cs
│   │   └── GetAllYourEntitiesQuery.cs
│   ├── DTOs/                   # 数据传输对象
│   │   └── YourEntityDto.cs
│   ├── Validators/             # FluentValidation验证器
│   │   └── CreateYourEntityCommandValidator.cs
│   ├── Handlers/               # 命令/查询处理器
│   │   ├── CreateYourEntityCommandHandler.cs
│   │   └── GetYourEntityQueryHandler.cs
│   └── Mappings/               # Mapster映射配置（可选）
├── Infrastructure/             # 基础设施层
│   ├── Persistence/            # 持久化
│   │   ├── YourModuleDbContext.cs
│   │   └── Configurations/    # EF Core配置
│   │       └── YourEntityConfiguration.cs
│   └── Repositories/          # 仓储实现
│       └── YourEntityRepository.cs
└── YourModule.cs               # 模块定义（必需）
```

### 2. 创建项目

```bash
# 创建类库项目
dotnet new classlib -n Lemoo.Modules.YourModule -f net10.0

# 添加项目引用
dotnet add reference ..\..\Modules\Lemoo.Modules.Abstractions\Lemoo.Modules.Abstractions.csproj
dotnet add reference ..\..\Core\Lemoo.Core.Abstractions\Lemoo.Core.Abstractions.csproj
dotnet add reference ..\..\Core\Lemoo.Core.Application\Lemoo.Core.Application.csproj
dotnet add reference ..\..\Core\Lemoo.Core.Domain\Lemoo.Core.Domain.csproj

# 添加NuGet包
dotnet add package MediatR
dotnet add package FluentValidation
dotnet add package FluentValidation.DependencyInjectionExtensions
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Mapster
```

### 3. 实现模块类

**必需文件：`YourModule.cs`**

```csharp
using Lemoo.Modules.Abstractions;
using Lemoo.Core.Application.Extensions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace Lemoo.Modules.YourModule;

/// <summary>
/// YourModule 模块定义
/// </summary>
public class YourModule : ModuleBase
{
    public override string Name => "YourModule";
    public override string Version => "1.0.0";
    public override string Description => "您的业务模块描述";
    
    /// <summary>
    /// 模块依赖（可选）
    /// </summary>
    public override IReadOnlyList<string> Dependencies => Array.Empty<string>();
    // 如果有依赖：public override IReadOnlyList<string> Dependencies => new[] { "Example" };
    
    /// <summary>
    /// 配置服务
    /// </summary>
    public override void ConfigureServices(IServiceCollection services, IConfiguration configuration)
    {
        // 1. 注册数据库上下文
        var connectionString = configuration.GetConnectionString("YourModule");
        if (!string.IsNullOrEmpty(connectionString))
        {
            services.AddDbContext<YourModuleDbContext>(options =>
            {
                options.UseSqlServer(connectionString);
            });
        }
        
        // 2. 注册仓储（如果使用仓储模式）
        services.AddScoped<IYourEntityRepository, YourEntityRepository>();
        
        // 3. 注册 MediatR（CQRS）
        services.AddMediatR(cfg =>
        {
            cfg.RegisterServicesFromAssembly(typeof(YourModule).Assembly);
        });
        
        // 4. 注册 FluentValidation
        services.AddValidatorsFromAssembly(typeof(YourModule).Assembly);
        
        // 5. 注册 CQRS 管道行为（验证、日志、缓存、事务）
        services.AddCqrsPipelineBehaviors();
        
        // 6. 注册其他服务
        // services.AddScoped<IYourService, YourService>();
    }
    
    /// <summary>
    /// 配置数据库上下文（用于迁移和工厂）
    /// </summary>
    public override void ConfigureDbContext(DbContextOptionsBuilder optionsBuilder, IConfiguration configuration)
    {
        var connectionString = configuration.GetConnectionString("YourModule");
        if (!string.IsNullOrEmpty(connectionString))
        {
            optionsBuilder.UseSqlServer(connectionString);
        }
    }
    
    /// <summary>
    /// 配置数据库模型（可选）
    /// </summary>
    public override void ConfigureDbContext(ModelBuilder modelBuilder)
    {
        base.ConfigureDbContext(modelBuilder);
        
        // 应用实体配置
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(YourModule).Assembly);
    }
    
    /// <summary>
    /// 应用程序启动后（可选）
    /// </summary>
    public override async Task OnApplicationStartedAsync(IServiceProvider serviceProvider, CancellationToken cancellationToken)
    {
        // 执行启动后的初始化操作
        // 例如：数据迁移、缓存预热等
        await base.OnApplicationStartedAsync(serviceProvider, cancellationToken);
    }
}
```

### 4. 实现领域模型

**示例：`Domain/Entities/YourEntity.cs`**

```csharp
using Lemoo.Core.Domain;

namespace Lemoo.Modules.YourModule.Domain.Entities;

public class YourEntity : AggregateRoot<Guid>
{
    public string Name { get; private set; } = string.Empty;
    public string Description { get; private set; } = string.Empty;
    public bool IsActive { get; private set; }
    
    // 私有构造函数（EF Core要求）
    private YourEntity() { }
    
    // 工厂方法
    public static YourEntity Create(string name, string description)
    {
        var entity = new YourEntity
        {
            Id = Guid.NewGuid(),
            Name = name,
            Description = description,
            IsActive = true,
            CreatedAt = DateTime.UtcNow
        };
        
        // 发布领域事件
        entity.AddDomainEvent(new YourEntityCreatedEvent(entity.Id, entity.Name));
        
        return entity;
    }
    
    public void Update(string name, string description)
    {
        Name = name;
        Description = description;
        UpdatedAt = DateTime.UtcNow;
        
        AddDomainEvent(new YourEntityUpdatedEvent(Id, Name));
    }
    
    public void Activate()
    {
        if (!IsActive)
        {
            IsActive = true;
            AddDomainEvent(new YourEntityActivatedEvent(Id));
        }
    }
    
    public void Deactivate()
    {
        if (IsActive)
        {
            IsActive = false;
            AddDomainEvent(new YourEntityDeactivatedEvent(Id));
        }
    }
}
```

### 5. 实现CQRS命令和查询

**示例：`Application/Commands/CreateYourEntityCommand.cs`**

```csharp
using Lemoo.Core.Abstractions.CQRS;

namespace Lemoo.Modules.YourModule.Application.Commands;

public record CreateYourEntityCommand(string Name, string Description) 
    : ICommand<Result<YourEntityDto>>;
```

**示例：`Application/Handlers/CreateYourEntityCommandHandler.cs`**

```csharp
using Lemoo.Core.Abstractions.CQRS;
using Lemoo.Modules.YourModule.Application.DTOs;
using Lemoo.Modules.YourModule.Domain.Entities;
using MediatR;

namespace Lemoo.Modules.YourModule.Application.Handlers;

public class CreateYourEntityCommandHandler 
    : ICommandHandler<CreateYourEntityCommand, Result<YourEntityDto>>
{
    private readonly IYourEntityRepository _repository;
    
    public CreateYourEntityCommandHandler(IYourEntityRepository repository)
    {
        _repository = repository;
    }
    
    public async Task<Result<YourEntityDto>> Handle(
        CreateYourEntityCommand request, 
        CancellationToken cancellationToken)
    {
        var entity = YourEntity.Create(request.Name, request.Description);
        
        await _repository.AddAsync(entity, cancellationToken);
        await _repository.SaveChangesAsync(cancellationToken);
        
        var dto = entity.Adapt<YourEntityDto>();
        return Result<YourEntityDto>.Success(dto);
    }
}
```

### 6. 实现数据库上下文

**示例：`Infrastructure/Persistence/YourModuleDbContext.cs`**

```csharp
using Lemoo.Modules.YourModule.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace Lemoo.Modules.YourModule.Infrastructure.Persistence;

public class YourModuleDbContext : DbContext
{
    public YourModuleDbContext(DbContextOptions<YourModuleDbContext> options) 
        : base(options)
    {
    }
    
    public DbSet<YourEntity> YourEntities { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        
        // 应用配置
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(YourModuleDbContext).Assembly);
    }
}
```

### 7. 项目文件配置

**`Lemoo.Modules.YourModule.csproj`**

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\..\Modules\Lemoo.Modules.Abstractions\Lemoo.Modules.Abstractions.csproj" />
    <ProjectReference Include="..\..\Core\Lemoo.Core.Abstractions\Lemoo.Core.Abstractions.csproj" />
    <ProjectReference Include="..\..\Core\Lemoo.Core.Application\Lemoo.Core.Application.csproj" />
    <ProjectReference Include="..\..\Core\Lemoo.Core.Domain\Lemoo.Core.Domain.csproj" />
  </ItemGroup>
  
  <ItemGroup>
    <PackageReference Include="MediatR" Version="12.0.1" />
    <PackageReference Include="FluentValidation" Version="11.8.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.8.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="10.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Mapster" Version="7.8.0" />
  </ItemGroup>
</Project>
```

---

## UI模块创建标准

### 1. 项目结构

```
Lemoo.Modules.YourModule.UI/
├── Views/                      # 视图（WPF页面）
│   └── Pages/                 # 页面
│       ├── YourEntityListPage.xaml
│       ├── YourEntityListPage.xaml.cs
│       ├── YourEntityDetailPage.xaml
│       └── YourEntityDetailPage.xaml.cs
├── ViewModels/                # 视图模型（MVVM）
│   ├── YourEntityListViewModel.cs
│   └── YourEntityDetailViewModel.cs
├── Services/                  # UI服务（可选）
│   └── YourModuleNavigationService.cs
└── YourModuleUI.cs            # 模块UI定义（必需）
```

### 2. 创建项目

```bash
# 创建WPF用户控件库项目
dotnet new classlib -n Lemoo.Modules.YourModule.UI -f net10.0

# 添加项目引用
dotnet add reference ..\..\Core\Lemoo.Core.Abstractions\Lemoo.Core.Abstractions.csproj
dotnet add reference ..\..\UI\Lemoo.UI.WPF\Lemoo.UI.WPF.csproj

# 添加NuGet包
dotnet add package Microsoft.Extensions.DependencyInjection
dotnet add package CommunityToolkit.Mvvm  # 可选，用于MVVM
```

### 3. 实现模块UI类

**必需文件：`YourModuleUI.cs`**

```csharp
using Lemoo.Core.Abstractions.UI;
using Microsoft.Extensions.DependencyInjection;

namespace Lemoo.Modules.YourModule.UI;

/// <summary>
/// YourModule UI模块定义
/// </summary>
public class YourModuleUI : IModuleUI
{
    /// <summary>
    /// 模块名称（必须与后端模块名称一致）
    /// </summary>
    public string ModuleName => "YourModule";
    
    /// <summary>
    /// 注册UI组件（页面、视图模型等）
    /// </summary>
    public void RegisterUI(IServiceCollection services)
    {
        // 注册视图模型（使用Transient，每次创建新实例）
        services.AddTransient<ViewModels.YourEntityListViewModel>();
        services.AddTransient<ViewModels.YourEntityDetailViewModel>();
        
        // 注册UI服务（如果有）
        // services.AddScoped<IYourModuleNavigationService, YourModuleNavigationService>();
    }
    
    /// <summary>
    /// 获取导航项配置
    /// </summary>
    public IReadOnlyList<NavigationItemMetadata> GetNavigationItems()
    {
        return new List<NavigationItemMetadata>
        {
            new NavigationItemMetadata
            {
                PageKey = "your-entity-list",           // 页面键（唯一标识，kebab-case）
                Title = "实体列表",                      // 显示标题
                Icon = "\uE8A5",                        // Segoe MDL2 Assets图标字符
                Module = ModuleName,                     // 所属模块
                Description = "查看和管理实体列表",        // 描述
                IsEnabled = true,                        // 是否启用
                Order = 1                                // 排序顺序
            },
            new NavigationItemMetadata
            {
                PageKey = "your-entity-detail",
                Title = "实体详情",
                Icon = "\uE8A5",
                Module = ModuleName,
                Description = "查看实体详细信息",
                IsEnabled = true,
                Order = 2,
                ParentPageKey = "your-entity-list"      // 父导航项（构建层级结构）
            }
        };
    }
}
```

### 4. 实现WPF页面

**示例：`Views/Pages/YourEntityListPage.xaml`**

```xml
<Page x:Class="Lemoo.Modules.YourModule.UI.Views.Pages.YourEntityListPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      mc:Ignorable="d"
      d:DesignHeight="450" d:DesignWidth="800"
      Title="实体列表">
    <Grid>
        <DataGrid ItemsSource="{Binding Entities}" 
                  AutoGenerateColumns="False"
                  IsReadOnly="True">
            <DataGrid.Columns>
                <DataGridTextColumn Header="名称" Binding="{Binding Name}" Width="200"/>
                <DataGridTextColumn Header="描述" Binding="{Binding Description}" Width="*"/>
                <DataGridCheckBoxColumn Header="激活" Binding="{Binding IsActive}" Width="100"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Page>
```

**示例：`Views/Pages/YourEntityListPage.xaml.cs`**

```csharp
using System.Windows.Controls;
using Lemoo.Modules.YourModule.UI.ViewModels;

namespace Lemoo.Modules.YourModule.UI.Views.Pages;

/// <summary>
/// YourEntityListPage.xaml 的交互逻辑
/// </summary>
public partial class YourEntityListPage : Page
{
    public YourEntityListPage(YourEntityListViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
    }
}
```

**重要命名约定**：
- PageKey `your-entity-list` → 类名 `YourEntityListPage`
- PageKey `your-entity-detail` → 类名 `YourEntityDetailPage`
- 转换规则：kebab-case → PascalCase + "Page"

### 5. 实现视图模型

**示例：`ViewModels/YourEntityListViewModel.cs`**

```csharp
using System.Collections.ObjectModel;
using System.Windows.Input;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using MediatR;
using Lemoo.Modules.YourModule.Application.Queries;
using Lemoo.Modules.YourModule.Application.DTOs;

namespace Lemoo.Modules.YourModule.UI.ViewModels;

public partial class YourEntityListViewModel : ObservableObject
{
    private readonly IMediator _mediator;
    
    [ObservableProperty]
    private ObservableCollection<YourEntityDto> _entities = new();
    
    [ObservableProperty]
    private bool _isLoading;
    
    public YourEntityListViewModel(IMediator mediator)
    {
        _mediator = mediator;
        LoadEntitiesCommand = new AsyncRelayCommand(LoadEntitiesAsync);
    }
    
    public ICommand LoadEntitiesCommand { get; }
    
    private async Task LoadEntitiesAsync()
    {
        IsLoading = true;
        try
        {
            var query = new GetAllYourEntitiesQuery();
            var result = await _mediator.Send(query);
            
            if (result.IsSuccess && result.Value != null)
            {
                Entities.Clear();
                foreach (var entity in result.Value)
                {
                    Entities.Add(entity);
                }
            }
        }
        finally
        {
            IsLoading = false;
        }
    }
}
```

### 6. 项目文件配置

**`Lemoo.Modules.YourModule.UI.csproj`**

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <UseWPF>true</UseWPF>
  </PropertyGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\..\Core\Lemoo.Core.Abstractions\Lemoo.Core.Abstractions.csproj" />
    <ProjectReference Include="..\..\UI\Lemoo.UI.WPF\Lemoo.UI.WPF.csproj" />
    <ProjectReference Include="..\Lemoo.Modules.YourModule\Lemoo.Modules.YourModule.csproj" />
  </ItemGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="10.0.0" />
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.2.2" />
  </ItemGroup>
  
  <ItemGroup>
    <Page Update="Views\Pages\**\*.xaml">
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
</Project>
```

---

## 模块集成流程

### 1. 后端模块集成流程

```
1. 创建模块项目
   ↓
2. 实现 ModuleBase 或 IModule
   ↓
3. 配置 appsettings.json（连接字符串、启用模块）
   ↓
4. 构建项目
   ↓
5. 部署到 Modules 目录（或通过项目引用）
   ↓
6. 应用程序启动时自动发现和加载
   ↓
7. ModuleLoader 验证依赖并排序
   ↓
8. Bootstrapper 调用 ConfigureServices
   ↓
9. 模块服务注册完成
```

### 2. UI模块集成流程

```
1. 创建UI模块项目
   ↓
2. 实现 IModuleUI 接口
   ↓
3. 创建页面和视图模型
   ↓
4. 配置导航项
   ↓
5. 构建项目
   ↓
6. 通过项目引用添加到 Host 项目
   ↓
7. 应用程序启动时自动发现
   ↓
8. Host 调用 RegisterUI 和 GetNavigationItems
   ↓
9. 页面注册到 PageRegistry
   ↓
10. 导航树构建完成
```

### 3. 自动发现机制

**后端模块发现**：
- 程序集命名：`Lemoo.Modules.{ModuleName}`
- 排除：`.Abstractions`、`.UI` 后缀
- 发现位置：
  1. `{ModulesPath}/*.dll`（文件系统）
  2. `AppDomain.CurrentDomain.GetAssemblies()`（已加载程序集）

**UI模块发现**：
- 程序集命名：`Lemoo.Modules.{ModuleName}.UI`
- 实现类型：`IModuleUI` 接口
- 发现位置：`AppDomain.CurrentDomain.GetAssemblies()`

**页面类型发现**：
- 命名空间：`Lemoo.Modules.{ModuleName}.UI.Views`
- 基类：`System.Windows.Controls.Page`
- 命名约定：`{PageKey转换为PascalCase}Page`

---

## 命名约定

### 后端模块

| 项目 | 命名规则 | 示例 |
|------|---------|------|
| 项目名称 | `Lemoo.Modules.{ModuleName}` | `Lemoo.Modules.Example` |
| 模块类 | `{ModuleName}Module` | `ExampleModule` |
| 实体 | `{EntityName}` | `ExampleEntity` |
| 命令 | `{Action}{EntityName}Command` | `CreateExampleCommand` |
| 查询 | `Get{EntityName}Query` | `GetExampleQuery` |
| DTO | `{EntityName}Dto` | `ExampleDto` |
| 处理器 | `{Command/Query}Handler` | `CreateExampleCommandHandler` |
| 数据库上下文 | `{ModuleName}DbContext` | `ExampleDbContext` |
| 仓储接口 | `I{EntityName}Repository` | `IExampleRepository` |
| 仓储实现 | `{EntityName}Repository` | `ExampleRepository` |

### UI模块

| 项目 | 命名规则 | 示例 |
|------|---------|------|
| 项目名称 | `Lemoo.Modules.{ModuleName}.UI` | `Lemoo.Modules.Example.UI` |
| 模块UI类 | `{ModuleName}UI` | `ExampleUI` |
| 页面类 | `{PageKey转换为PascalCase}Page` | `ExampleListPage` |
| 视图模型 | `{PageKey转换为PascalCase}ViewModel` | `ExampleListViewModel` |
| PageKey | kebab-case | `example-list` |

### PageKey 转换规则

```
PageKey: "example-list" → 类名: "ExampleListPage"
PageKey: "your-entity-detail" → 类名: "YourEntityDetailPage"
PageKey: "user-profile-settings" → 类名: "UserProfileSettingsPage"
```

转换逻辑：
1. 按 `-` 分割
2. 每个部分首字母大写
3. 拼接后加 `Page` 后缀

---

## 配置要求

### 1. appsettings.json

```json
{
  "Lemoo": {
    "Mode": "Local",
    "Modules": {
      "Enabled": [ "*" ],  // 启用所有模块，或指定模块名称数组
      "Path": "./Modules"  // 模块DLL路径（可选，支持项目引用）
    },
    "Database": {
      "Provider": "SqlServer",
      "ConnectionStrings": {
        "YourModule": "Server=localhost;Database=Lemoo_YourModule;Integrated Security=true;TrustServerCertificate=true;"
      }
    }
  }
}
```

### 2. 解决方案配置

**在 `Lemoo.Host.csproj` 中添加项目引用**：

```xml
<ItemGroup>
  <!-- 后端模块引用（可选，用于开发时） -->
  <ProjectReference Include="..\..\Modules\Lemoo.Modules.YourModule\Lemoo.Modules.YourModule.csproj" />
  
  <!-- UI模块引用（必需，用于自动发现） -->
  <ProjectReference Include="..\..\Modules\Lemoo.Modules.YourModule.UI\Lemoo.Modules.YourModule.UI.csproj" />
</ItemGroup>
```

### 3. 模块启用配置

**启用所有模块**：
```json
"Enabled": [ "*" ]
```

**启用指定模块**：
```json
"Enabled": [ "Example", "YourModule" ]
```

**禁用所有模块**：
```json
"Enabled": [ ]
```

---

## 依赖管理

### 1. 声明模块依赖

在模块类中声明依赖：

```csharp
public class YourModule : ModuleBase
{
    public override IReadOnlyList<string> Dependencies => new[] { "Example" };
    // ...
}
```

### 2. 依赖解析

- `ModuleLoader` 自动解析依赖关系
- 使用拓扑排序确保加载顺序
- 检测循环依赖并抛出异常

### 3. 依赖顺序

模块按以下顺序配置：
1. 无依赖的模块
2. 依赖已加载模块的模块
3. 依次递归

---

## 最佳实践

### 1. 模块设计

- ✅ **单一职责**：每个模块只负责一个业务领域
- ✅ **独立性**：模块间通过接口和事件通信，避免直接依赖
- ✅ **接口抽象**：使用接口定义模块间契约
- ✅ **领域事件**：使用领域事件实现模块间解耦通信

### 2. 代码组织

- ✅ **分层清晰**：严格遵循 Domain、Application、Infrastructure 分层
- ✅ **命名规范**：遵循命名约定，保持一致性
- ✅ **注释完整**：为公共API添加XML注释
- ✅ **异常处理**：使用 `Result<T>` 模式统一错误处理

### 3. UI设计

- ✅ **MVVM模式**：使用MVVM模式分离视图和逻辑
- ✅ **依赖注入**：视图模型通过构造函数注入依赖
- ✅ **异步操作**：所有I/O操作使用异步方法
- ✅ **响应式UI**：使用 `ObservableProperty` 实现数据绑定

### 4. 性能优化

- ✅ **延迟加载**：页面按需创建，不预加载所有页面
- ✅ **缓存策略**：合理使用缓存减少数据库查询
- ✅ **批量操作**：支持批量查询和更新
- ✅ **分页查询**：大数据集使用分页

### 5. 测试

- ✅ **单元测试**：为业务逻辑编写单元测试
- ✅ **集成测试**：为模块集成编写集成测试
- ✅ **UI测试**：为关键UI流程编写UI测试

---

## 常见问题

### Q1: 模块未被发现？

**可能原因**：
1. 程序集命名不符合约定
2. 模块未实现 `IModule` 接口
3. 模块未在 `Enabled` 列表中
4. 项目引用未添加到 Host 项目

**解决方案**：
- 检查程序集名称：`Lemoo.Modules.{ModuleName}`
- 确认模块类继承 `ModuleBase` 或实现 `IModule`
- 检查 `appsettings.json` 中的 `Enabled` 配置
- 确认项目引用已添加

### Q2: UI模块页面未显示？

**可能原因**：
1. `ModuleName` 与后端模块不一致
2. PageKey 转换后的类名不匹配
3. 页面未在 `Views` 命名空间下
4. 页面类未继承 `Page`

**解决方案**：
- 确认 `IModuleUI.ModuleName` 与后端模块名称一致
- 检查 PageKey → 类名转换是否正确
- 确认页面在 `Lemoo.Modules.{ModuleName}.UI.Views` 命名空间
- 确认页面继承 `System.Windows.Controls.Page`

### Q3: 模块依赖加载失败？

**可能原因**：
1. 依赖模块未启用
2. 循环依赖
3. 依赖模块加载失败

**解决方案**：
- 检查依赖模块是否在 `Enabled` 列表中
- 检查是否存在循环依赖
- 查看日志了解依赖模块加载失败原因

### Q4: 数据库迁移如何执行？

**解决方案**：
```bash
# 在模块项目目录下执行
dotnet ef migrations add InitialCreate --context YourModuleDbContext --startup-project ../../Hosts/Lemoo.Host/Lemoo.Host.csproj

# 应用迁移
dotnet ef database update --context YourModuleDbContext --startup-project ../../Hosts/Lemoo.Host/Lemoo.Host.csproj
```

### Q5: 如何调试模块？

**解决方案**：
1. 将模块项目添加到解决方案
2. 在 Host 项目中添加项目引用
3. 设置断点并启动调试
4. 模块会自动从项目引用加载，无需部署到 Modules 目录

---

## 附录

### A. 完整示例项目结构

```
Lemoo.Modules.Example/
├── Domain/
│   ├── Entities/
│   │   └── ExampleEntity.cs
│   └── DomainEvents/
│       └── ExampleCreatedEvent.cs
├── Application/
│   ├── Commands/
│   │   └── CreateExampleCommand.cs
│   ├── Queries/
│   │   └── GetExampleQuery.cs
│   ├── DTOs/
│   │   └── ExampleDto.cs
│   ├── Validators/
│   │   └── CreateExampleCommandValidator.cs
│   └── Handlers/
│       ├── CreateExampleCommandHandler.cs
│       └── GetExampleQueryHandler.cs
├── Infrastructure/
│   ├── Persistence/
│   │   └── ExampleDbContext.cs
│   └── Repositories/
│       └── ExampleRepository.cs
└── ExampleModule.cs

Lemoo.Modules.Example.UI/
├── Views/
│   └── Pages/
│       ├── ExampleListPage.xaml
│       └── ExampleListPage.xaml.cs
├── ViewModels/
│   └── ExampleListViewModel.cs
└── ExampleUI.cs
```

### B. 相关接口和基类

- `IModule` - 模块接口
- `ModuleBase` - 模块基类
- `IModuleUI` - 模块UI接口
- `NavigationItemMetadata` - 导航项元数据
- `IPageRegistry` - 页面注册表接口

### C. 参考文档

- [架构文档](./architecture.md)
- [模块开发指南](./modules.md)
- [使用说明](./使用说明.md)

---

**文档版本**：1.0.0  
**最后更新**：2024年  
**维护者**：Lemoo 开发团队
