# Lemoo.UI 改进建议

## 已完成的改进 ✅

### 1. 错误处理增强 - 建立完整的错误码体系

**实现位置**:
- `src/Core/Lemoo.Core.Common/Errors/LemooErrors.cs` - 错误码定义
- `src/Core/Lemoo.Core.Common/Errors/ErrorDetail.cs` - 错误详情类
- `src/Core/Lemoo.Core.Application/Common/Result.cs` - 增强的 Result 类型

**主要改进**:
- 定义了完整的错误码体系（LEM001-LEM599）
- 增加了 `ErrorDetail` 类型支持详细错误信息
- Result 类型支持带错误码的失败结果
- 添加了 `BindAsync` 方法支持异步链式操作

**使用示例**:
```csharp
// 使用错误码
var result = Result.Failure(
    LemooErrors.ENTITY_NOT_FOUND,
    "Task not found",
    $"Task with ID {taskId} was not found");

// 使用 ErrorDetail
var errorDetail = ErrorDetail.Create(
    LemooErrors.VALIDATION_FAILED,
    "Validation failed")
    .WithDetails("Required field is missing")
    .WithMetadata("FieldName", "Title");

var result = Result.Failure(errorDetail);
```

---

### 2. 异步处理优化 - 改造 IModule 接口为完全异步

**实现位置**:
- `src/Core/Lemoo.Core.Abstractions/Module/IModule.cs` - 添加异步方法
- `src/Modules/Lemoo.Modules.Abstractions/ModuleBase.cs` - 实现默认异步行为
- `src/Hosts/Lemoo.Bootstrap/IBootstrapper.cs` - 添加异步注册接口
- `src/Hosts/Lemoo.Bootstrap/Bootstrapper.cs` - 实现异步服务注册

**主要改进**:
- 为 IModule 接口添加了异步版本的配置方法
- ModuleBase 默认实现调用同步方法，保持向后兼容
- Bootstrapper 添加了 `RegisterServicesAsync` 方法
- 支持模块的完全异步配置

**使用示例**:
```csharp
// 在模块中重写异步方法
public class YourModule : ModuleBase
{
    public override async Task ConfigureServicesAsync(
        IServiceCollection services,
        IConfiguration configuration,
        CancellationToken cancellationToken = default)
    {
        // 异步配置服务
        await ConfigureDatabaseAsync(services, cancellationToken);
        await RegisterServicesAsync(services, cancellationToken);
    }
}

// 在 Bootstrapper 中使用异步注册
await bootstrapper.RegisterServicesAsync(services, configuration, cancellationToken);
```

---

### 3. 添加单元测试 - 为 Result 类型添加测试

**实现位置**:
- `tests/Lemoo.Core.Application.Tests/Common/ResultTests.cs` - Result 测试
- `tests/Lemoo.Core.Application.Tests/ErrorDetailTests.cs` - ErrorDetail 测试

**测试覆盖**:
- ✅ Success/Failure 结果创建
- ✅ 错误详情处理
- ✅ OnSuccess/OnFailure 回调
- ✅ Map 转换
- ✅ Bind 链式操作
- ✅ BindAsync 异步链式操作
- ✅ Match 模式匹配
- ✅ ValueOr 默认值

**测试结果**: 39 个测试全部通过

---

### 4. 添加 Docker 支持

**实现位置**:
- `Dockerfile` - API 容器化配置
- `.dockerignore` - Docker 构建忽略文件
- `docker-compose.yml` - 完整的容器编排配置

**包含服务**:
- lemoo-api - 主应用服务
- sqlserver - SQL Server 数据库
- redis - Redis 缓存
- rabbitmq - 消息队列

**使用方式**:
```bash
# 构建并启动所有服务
docker-compose up -d

# 查看日志
docker-compose logs -f lemoo-api

# 停止所有服务
docker-compose down
```

---

### 5. 添加 CI/CD 配置

**实现位置**:
- `.github/workflows/build.yml` - 构建和测试工作流
- `.github/workflows/codeql.yml` - 代码安全分析

**CI/CD 功能**:
- 自动构建和测试
- Windows 和 Linux 双平台支持
- Docker 镜像自动构建和推送
- CodeQL 安全分析
- 测试结果上传

---

## 待实施的改进

## 架构层面

### 1. 异步处理优化

**问题位置**: `Lemoo.Bootstrap/Bootstrapper.cs:RegisterServices`

**问题描述**:
```csharp
// 当前实现：使用 GetAwaiter().GetResult() 同步等待异步方法
foreach (var module in sortedModules)
{
    module.PreConfigureServices(services, configuration, environment);
    // ...
}
```

**风险**: 可能导致死锁，尤其是在 WPF/UI 线程中

**建议修改**:
```csharp
// 改为完全异步
public async Task RegisterServicesAsync(
    IServiceCollection services,
    IConfiguration configuration,
    IHostEnvironment environment)
{
    foreach (var module in sortedModules)
    {
        await module.PreConfigureServicesAsync(services, configuration, environment);
    }

    foreach (var module in sortedModules)
    {
        await module.ConfigureServicesAsync(services, configuration, environment);
    }

    foreach (var module.Reverse())
    {
        await module.PostConfigureServicesAsync(services, configuration, environment);
    }
}
```

**状态**: ✅ 已完成

### 2. 模块加载策略模式

### 2. 模块加载策略模式

**问题位置**: `Lemoo.Core.Infrastructure/ModuleLoader/ModuleLoader.cs`

**问题描述**: 模块发现逻辑硬编码，缺乏灵活性

**建议实现**:

```csharp
// 定义策略接口
public interface IModuleDiscoveryStrategy
{
    Task<IEnumerable<Assembly>> DiscoverModulesAsync(CancellationToken cancellationToken = default);
}

// 文件系统策略
public class FileSystemModuleDiscoveryStrategy : IModuleDiscoveryStrategy
{
    private readonly string _modulePath;

    public FileSystemModuleDiscoveryStrategy(string modulePath)
    {
        _modulePath = modulePath;
    }

    public async Task<IEnumerable<Assembly>> DiscoverModulesAsync(CancellationToken cancellationToken = default)
    {
        var assemblies = new List<Assembly>();

        if (Directory.Exists(_modulePath))
        {
            var dllFiles = Directory.GetFiles(_modulePath, "*.Module.dll");
            foreach (var dllFile in dllFiles)
            {
                var assembly = Assembly.LoadFrom(dllFile);
                assemblies.Add(assembly);
            }
        }

        return await Task.FromResult(assemblies);
    }
}

// 配置化策略
public class ConfigurableModuleDiscoveryStrategy : IModuleDiscoveryStrategy
{
    private readonly ModuleDiscoveryOptions _options;

    public ConfigurableModuleDiscoveryStrategy(IOptions<ModuleDiscoveryOptions> options)
    {
        _options = options.Value;
    }

    public async Task<IEnumerable<Assembly>> DiscoverModulesAsync(CancellationToken cancellationToken = default)
    {
        var assemblies = new List<Assembly>();

        // 从配置文件读取路径
        foreach (var path in _options.Paths)
        {
            if (Directory.Exists(path))
            {
                var dllFiles = Directory.GetFiles(path, "*.dll");
                foreach (var dllFile in dllFiles)
                {
                    if (_options.Filter?.Invoke(dllFile) ?? true)
                    {
                        var assembly = Assembly.LoadFrom(dllFile);
                        assemblies.Add(assembly);
                    }
                }
            }
        }

        // 从已加载程序集发现
        foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            if (_options.Filter?.Invoke(assembly.Location) ?? true)
            {
                if (assembly.GetTypes().Any(t => typeof(IModule).IsAssignableFrom(t)))
                {
                    assemblies.Add(assembly);
                }
            }
        }

        return await Task.FromResult(assemblies);
    }
}

// 选项配置
public class ModuleDiscoveryOptions
{
    public List<string> Paths { get; set; } = new();
    public Func<string, bool>? Filter { get; set; }
    public bool IncludeLoadedAssemblies { get; set; } = true;
}

// 修改后的 ModuleLoader
public class ModuleLoader : IModuleLoader
{
    private readonly IEnumerable<IModuleDiscoveryStrategy> _discoveryStrategies;

    public ModuleLoader(IEnumerable<IModuleDiscoveryStrategy> discoveryStrategies)
    {
        _discoveryStrategies = discoveryStrategies;
    }

    public async Task<ModuleLoadResult> LoadModulesAsync(CancellationToken cancellationToken = default)
    {
        var assemblies = new List<Assembly>();

        // 使用所有策略发现模块
        foreach (var strategy in _discoveryStrategies)
        {
            var discovered = await strategy.DiscoverModulesAsync(cancellationToken);
            assemblies.AddRange(discovered);
        }

        // ... 后续处理
    }
}
```

**配置示例**:
```json
{
  "ModuleDiscovery": {
    "Paths": [
      "./Modules",
      "./CustomModules",
      "./ThirdPartyModules"
    ],
    "IncludeLoadedAssemblies": true,
    "FilePattern": "*.Module.dll"
  }
}
```

### 3. 错误处理增强

**建议**: 建立完整的错误码体系

```csharp
// 错误码定义
public static class LemooErrors
{
    public const string MODULE_NOT_FOUND = "LEM001";
    public const string MODULE_LOAD_FAILED = "LEM002";
    public const string CIRCULAR_DEPENDENCY = "LEM003";
    public const string MISSING_DEPENDENCY = "LEM004";
    public const string VALIDATION_FAILED = "LEM005";
}

// 错误详情
public record ErrorDetail
{
    public required string Code { get; init; }
    public required string Message { get; init; }
    public string? Details { get; init; }
    public Dictionary<string, object>? Metadata { get; init; }
}

// 增强的 Result 类型
public record Result
{
    public bool IsSuccess { get; }
    public bool IsFailure => !IsSuccess;
    public ErrorDetail? Error { get; }

    public static Result Success() => new(true, null);
    public static Result Failure(string code, string message, string? details = null) =>
        new(false, new ErrorDetail { Code = code, Message = message, Details = details });
}

public record Result<T> : Result
{
    public T? Value { get; }

    public static Result<T> Success(T value) => new(true, value, null);
    public static new Result<T> Failure(string code, string message, string? details = null) =>
        new(false, default, new ErrorDetail { Code = code, Message = message, Details = details });
}
```

**使用示例**:
```csharp
// 模块加载失败
if (moduleType is null)
{
    return Result.Failure(
        LemooErrors.MODULE_LOAD_FAILED,
        $"Failed to load module from assembly {assembly.GetName().Name}",
        $"Assembly location: {assembly.Location}");
}

// 验证失败
return Result.Failure<Guid>(
    LemooErrors.VALIDATION_FAILED,
    "Task validation failed",
    $"Errors: {string.Join(", ", validationResult.Errors.Select(e => e.ErrorMessage))}");
```

### 4. 性能优化

#### 4.1 模块并行加载

```csharp
public async Task<ModuleLoadResult> LoadModulesAsync(CancellationToken cancellationToken = default)
{
    // 发现模块（可并行）
    var discoveryTasks = _discoveryStrategies.Select(strategy =>
        strategy.DiscoverModulesAsync(cancellationToken));

    var assemblyCollections = await Task.WhenAll(discoveryTasks);
    var assemblies = assemblyCollections.SelectMany(a => a).Distinct().ToList();

    // 实例化模块（可并行）
    var moduleInstances = await Task.WhenAll(assemblies.Select(async assembly =>
    {
        var moduleType = assembly.GetTypes()
            .FirstOrDefault(t => typeof(IModule).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract);

        return (IModule?)Activator.CreateInstance(moduleType!);
    }));

    var modules = moduleInstances.Where(m => m is not null).ToArray()!;

    // 拓扑排序（需要顺序）
    var sortedModules = TopologicalSort(modules);

    return new ModuleLoadResult(sortedModules);
}
```

#### 4.2 缓存优化

```csharp
// 模块元数据缓存
public interface IModuleMetadataCache
{
    Task<ModuleMetadata?> GetAsync(string moduleName);
    Task SetAsync(string moduleName, ModuleMetadata metadata);
    Task RemoveAsync(string moduleName);
}

public record ModuleMetadata
{
    public string Name { get; init; }
    public string Version { get; init; }
    public string Description { get; init; }
    public string[] Dependencies { get; init; }
    public DateTime LoadedAt { get; init; }
}

// 在 ModuleLoader 中使用
public class ModuleLoader : IModuleLoader
{
    private readonly IModuleMetadataCache _metadataCache;

    public async Task<ModuleLoadResult> LoadModulesAsync(CancellationToken cancellationToken = default)
    {
        // 尝试从缓存获取
        var cachedMetadata = await _metadataCache.GetAsync(moduleName);
        if (cachedMetadata != null)
        {
            // 使用缓存的元数据
        }
    }
}
```

#### 4.3 减少反射使用

```csharp
// 使用编译时生成的代码（Source Generator）
[ModuleGenerator]
public partial class TaskManagerModule : ModuleBase
{
    // Source Generator 自动生成：
    // - 模块元数据
    // - 服务注册代码
    // - DbContext 配置
}

// 或者使用表达式树缓存
public static class DelegateFactory
{
    private static readonly ConcurrentDictionary<Type, Func<object>> _constructors = new();

    public static T CreateInstance<T>(Type type)
    {
        var constructor = _constructors.GetOrAdd(type, t =>
        {
            var ctor = t.GetConstructor(Type.EmptyTypes);
            var lambda = Expression.Lambda<Func<object>>(Expression.New(ctor!));
            return lambda.Compile();
        });

        return (T)constructor();
    }
}
```

## 代码质量

### 1. 添加单元测试

**状态**: ✅ 已完成

**实现内容**:
- 为 Result 类型添加了完整的单元测试（39 个测试用例）
- 为 ErrorDetail 类型添加了单元测试
- 所有测试通过

### 2. 添加集成测试

**建议**: 为核心组件添加单元测试

```
tests/
├── Lemoo.Core.Abstractions.Tests/
│   ├── CQRS/
│   │   └── CommandTests.cs
│   └── Domain/
│       └── EntityTests.cs
├── Lemoo.Core.Application.Tests/
│   ├── Behaviors/
│   │   ├── ValidationBehaviorTests.cs
│   │   ├── CacheBehaviorTests.cs
│   │   └── TransactionBehaviorTests.cs
│   └── Common/
│       └── ResultTests.cs
├── Lemoo.Core.Infrastructure.Tests/
│   ├── ModuleLoader/
│   │   └── ModuleLoaderTests.cs
│   └── Caching/
│       └── CacheServiceTests.cs
└── Lemoo.Modules.TaskManager.Tests/
    ├── Commands/
    │   └── CreateTaskCommandHandlerTests.cs
    └── Queries/
        └── GetTaskQueryHandlerTests.cs
```

**示例测试**:
```csharp
public class ResultTests
{
    [Fact]
    public void Success_Should_ReturnSuccessResult()
    {
        // Arrange & Act
        var result = Result.Success();

        // Assert
        Assert.True(result.IsSuccess);
        Assert.False(result.IsFailure);
        Assert.Null(result.Error);
    }

    [Fact]
    public void Failure_Should_ReturnFailureResult()
    {
        // Arrange & Act
        var result = Result.Failure("Test error");

        // Assert
        Assert.False(result.IsSuccess);
        Assert.True(result.IsFailure);
        Assert.Equal("Test error", result.Error);
    }

    [Fact]
    public void OnSuccess_Should_ExecuteAction_WhenSuccess()
    {
        // Arrange
        var result = Result.Success();
        var executed = false;

        // Act
        result.OnSuccess(() => executed = true);

        // Assert
        Assert.True(executed);
    }

    [Fact]
    public async Task Map_Should_TransformValue()
    {
        // Arrange
        var result = Result<int>.Success(42);

        // Act
        var mapped = result.Map(x => x.ToString());

        // Assert
        Assert.True(mapped.IsSuccess);
        Assert.Equal("42", mapped.Value);
    }
}
```

### 2. 添加集成测试

```csharp
public class ModuleLoaderIntegrationTests : IClassFixture<TestFixture>
{
    private readonly TestFixture _fixture;

    public ModuleLoaderIntegrationTests(TestFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public async Task LoadModulesAsync_Should_LoadAllModules()
    {
        // Arrange
        var moduleLoader = _fixture.GetModuleLoader();

        // Act
        var result = await moduleLoader.LoadModulesAsync();

        // Assert
        Assert.True(result.Success);
        Assert.NotEmpty(result.Modules);
        Assert.Contains(result.Modules, m => m.Name == "TaskManager");
    }
}
```

### 3. 代码文档

**建议**: 为公共 API 添加 XML 文档注释

```csharp
/// <summary>
/// 表示命令的结果，不返回值
/// </summary>
/// <example>
/// <code>
/// var result = await mediator.Send(new CreateTaskCommand(...));
/// if (result.IsFailure)
/// {
///     Console.WriteLine($"Error: {result.Error}");
/// }
/// </code>
/// </example>
public record Result
{
    /// <summary>
    /// 获取操作是否成功
    /// </summary>
    public bool IsSuccess { get; }

    /// <summary>
    /// 获取操作是否失败
    /// </summary>
    public bool IsFailure => !IsSuccess;

    /// <summary>
    /// 获取错误信息
    /// </summary>
    public string? Error { get; }

    /// <summary>
    /// 创建成功结果
    /// </summary>
    /// <returns>成功的结果</returns>
    public static Result Success() => new(true, null);

    /// <summary>
    /// 创建失败结果
    /// </summary>
    /// <param name="error">错误信息</param>
    /// <returns>失败的结果</returns>
    public static Result Failure(string error) => new(false, error);
}
```

## 功能增强

### 1. 模块热重载

```csharp
public interface IModuleHotReloadService
{
    event EventHandler<ModuleReloadedEventArgs> ModuleReloaded;
    Task ReloadModuleAsync(string moduleName);
    Task WatchModulesAsync(CancellationToken cancellationToken = default);
}

public class FileSystemModuleWatcher : IModuleHotReloadService
{
    private readonly IModuleLoader _moduleLoader;
    private readonly IServiceProvider _serviceProvider;

    public event EventHandler<ModuleReloadedEventArgs>? ModuleReloaded;

    public async Task WatchModulesAsync(CancellationToken cancellationToken = default)
    {
        var watcher = new FileSystemWatcher("./Modules")
        {
            Filter = "*.Module.dll",
            NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName
        };

        watcher.Changed += async (sender, e) =>
        {
            var moduleName = Path.GetFileNameWithoutExtension(e.Name);
            await ReloadModuleAsync(moduleName!);
        };

        watcher.EnableRaisingEvents = true;

        await Task.Delay(Timeout.Infinite, cancellationToken);
    }

    public async Task ReloadModuleAsync(string moduleName)
    {
        // 1. 卸载旧模块
        await UnloadModuleAsync(moduleName);

        // 2. 重新加载模块
        var result = await _moduleLoader.LoadModulesAsync();

        // 3. 重新配置服务
        using var scope = _serviceProvider.CreateScope();
        var module = result.Modules.FirstOrDefault(m => m.Name == moduleName);

        // 4. 通知应用
        ModuleReloaded?.Invoke(this, new ModuleReloadedEventArgs(moduleName, module));
    }
}
```

### 2. 模块版本管理

```csharp
public interface IModuleVersionManager
{
    Task<ModuleVersionInfo> GetVersionInfoAsync(string moduleName);
    Task<bool> CheckCompatibilityAsync(string moduleName, string requiredVersion);
    Task UpgradeModuleAsync(string moduleName, string targetVersion);
}

public record ModuleVersionInfo
{
    public string ModuleName { get; init; }
    public string CurrentVersion { get; init; }
    public string[] CompatibleVersions { get; init; }
    public DateTime InstalledAt { get; init; }
    public string[] Dependencies { get; init; }
}
```

### 3. 模块市场/仓库

```csharp
public interface IModuleRegistry
{
    Task<IEnumerable<ModuleManifest>> DiscoverModulesAsync();
    Task<Stream> DownloadModuleAsync(string moduleName, string version);
    Task InstallModuleAsync(string moduleName, string version);
}

public record ModuleManifest
{
    public string Name { get; init; }
    public string Description { get; init; }
    public string Version { get; init; }
    public string Author { get; init; }
    public Uri DownloadUrl { get; init; }
    public string[] Dependencies { get; init; }
    public long Size { get; init; }
    public string Checksum { get; init; }
}
```

### 4. 健康检查

```csharp
public interface IModuleHealthCheck
{
    Task<HealthCheckResult> CheckHealthAsync(CancellationToken cancellationToken = default);
}

public class ModuleHealthCheckService
{
    public async Task<Dictionary<string, HealthCheckResult>> CheckAllModulesAsync(
        CancellationToken cancellationToken = default)
    {
        var results = new Dictionary<string, HealthCheckResult>();

        foreach (var module in _modules)
        {
            var healthCheck = module as IModuleHealthCheck;
            if (healthCheck != null)
            {
                results[module.Name] = await healthCheck.CheckHealthAsync(cancellationToken);
            }
        }

        return results;
    }
}
```

## DevOps

### 1. 添加 Docker 支持

**状态**: ✅ 已完成

**实现内容**:
- Dockerfile 配置
- docker-compose.yml 包含完整服务栈
- 支持 SQL Server、Redis、RabbitMQ

### 2. CI/CD 配置

**状态**: ✅ 已完成

**实现内容**:
- GitHub Actions 构建工作流
- CodeQL 安全分析
- Docker 镜像自动推送

### 3. 性能测试

```dockerfile
# Dockerfile for API
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
WORKDIR /app

FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src
COPY ["src/Hosts/Lemoo.Api/Lemoo.Api.csproj", "Lemoo.Api/"]
RUN dotnet restore "Lemoo.Api/Lemoo.Api.csproj"
COPY . .
WORKDIR "/src/Lemoo.Api"
RUN dotnet build "Lemoo.Api.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "Lemoo.Api.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "Lemoo.Api.dll"]
```

### 2. CI/CD 配置

```yaml
# .github/workflows/build.yml
name: Build and Test

on:
  push:
    branches: [ master, develop ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '10.0.x'

    - name: Restore dependencies
      run: dotnet restore Lemoo.sln

    - name: Build
      run: dotnet build Lemoo.sln --configuration Release

    - name: Test
      run: dotnet test Lemoo.sln --configuration Release --no-build

    - name: Publish
      run: dotnet publish src/Hosts/Lemoo.Api/Lemoo.Api.csproj --configuration Release --output ./publish
```

### 3. 性能测试

```csharp
public class ModuleLoadPerformanceTests
{
    [Fact]
    public async Task LoadModulesAsync_Should_CompleteWithinTimeLimit()
    {
        // Arrange
        var moduleLoader = new ModuleLoader(...);
        var stopwatch = Stopwatch.StartNew();

        // Act
        await moduleLoader.LoadModulesAsync();
        stopwatch.Stop();

        // Assert
        Assert.True(stopwatch.ElapsedMilliseconds < 5000,
            $"Module loading took {stopwatch.ElapsedMilliseconds}ms, expected < 5000ms");
    }
}
```

## 总结

以下是按优先级排序的改进建议：

| 优先级 | 改进项 | 复杂度 | 影响 | 状态 |
|--------|--------|--------|------|------|
| 高 | 错误处理增强 | 低 | 提升用户体验 | ✅ 已完成 |
| 高 | 异步处理优化 | 中 | 避免死锁风险 | ✅ 已完成 |
| 中 | 添加单元测试 | 中 | 保证代码质量 | ✅ 已完成 |
| 中 | 添加 Docker 支持 | 中 | 容器化部署 | ✅ 已完成 |
| 中 | 添加 CI/CD 配置 | 中 | 自动化构建 | ✅ 已完成 |
| 中 | 模块加载策略模式 | 高 | 提升灵活性 | ✅ 已完成 |
| 中 | 模块热重载 | 高 | 开发体验 | ✅ 已完成 |
| 低 | 模块版本管理 | 中 | 运维便利 | ⏳ 待实施 |
| 低 | 模块市场 | 高 | 生态扩展 | ⏳ 待实施 |

---

## 新增功能说明

### 模块加载策略模式 ✅

**新增文件**:
- `src/Core/Lemoo.Core.Abstractions/Module/IModuleDiscoveryStrategy.cs` - 策略接口
- `src/Core/Lemoo.Core.Common/Module/ModuleDiscoveryOptions.cs` - 配置选项
- `src/Core/Lemoo.Core.Infrastructure/ModuleLoader/FileSystemModuleDiscoveryStrategy.cs` - 文件系统策略
- `src/Core/Lemoo.Core.Infrastructure/ModuleLoader/ConfigurableModuleDiscoveryStrategy.cs` - 可配置策略
- `src/Core/Lemoo.Core.Infrastructure/ModuleLoader/StrategyModuleLoader.cs` - 策略式加载器

**配置示例**:
```json
{
  "Lemoo": {
    "Modules": {
      "Discovery": {
        "Paths": ["./Modules", "./CustomModules"],
        "FilePattern": "*.Module.dll",
        "RecursiveSearch": true,
        "IncludeLoadedAssemblies": true,
        "ExcludedAssemblies": ["Test.Module"]
      }
    }
  }
}
```

### 模块热重载功能 ✅

**新增文件**:
- `src/Core/Lemoo.Core.Abstractions/Module/IModuleHotReloadService.cs` - 热重载服务接口
- `src/Core/Lemoo.Core.Infrastructure/ModuleLoader/FileSystemModuleWatcher.cs` - 文件监视器

**使用示例**:
```csharp
// 注册服务
services.AddSingleton<IModuleHotReloadService, FileSystemModuleWatcher>();
services.Configure<ModuleDiscoveryOptions>(configuration.GetSection("Lemoo:Modules:Discovery"));

// 启动监视
var watcher = serviceProvider.GetRequiredService<IModuleHotReloadService>();
watcher.ModuleReloaded += (sender, args) =>
{
    Console.WriteLine($"模块 {args.ModuleName} 已重新加载");
};

await watcher.WatchModulesAsync(cancellationToken);

// 手动重新加载
await watcher.ReloadModuleAsync("TaskManager");
```

---

## 文件清单

### 已添加/修改的文件

**错误处理**:
- `src/Core/Lemoo.Core.Common/Errors/LemooErrors.cs`
- `src/Core/Lemoo.Core.Common/Errors/ErrorDetail.cs`
- `src/Core/Lemoo.Core.Application/Common/Result.cs` (修改)

**异步处理**:
- `src/Core/Lemoo.Core.Abstractions/Module/IModule.cs` (修改)
- `src/Modules/Lemoo.Modules.Abstractions/ModuleBase.cs` (修改)
- `src/Hosts/Lemoo.Bootstrap/IBootstrapper.cs` (修改)
- `src/Hosts/Lemoo.Bootstrap/Bootstrapper.cs` (修改)

**模块策略**:
- `src/Core/Lemoo.Core.Abstractions/Module/IModuleDiscoveryStrategy.cs`
- `src/Core/Lemoo.Core.Abstractions/Module/ModuleLoadResult.cs`
- `src/Core/Lemoo.Core.Common/Module/ModuleDiscoveryOptions.cs`
- `src/Core/Lemoo.Core.Infrastructure/ModuleLoader/FileSystemModuleDiscoveryStrategy.cs`
- `src/Core/Lemoo.Core.Infrastructure/ModuleLoader/ConfigurableModuleDiscoveryStrategy.cs`
- `src/Core/Lemoo.Core.Infrastructure/ModuleLoader/StrategyModuleLoader.cs`

**热重载**:
- `src/Core/Lemoo.Core.Abstractions/Module/IModuleHotReloadService.cs`
- `src/Core/Lemoo.Core.Infrastructure/ModuleLoader/FileSystemModuleWatcher.cs`

**测试**:
- `tests/Lemoo.Core.Application.Tests/Lemoo.Core.Application.Tests.csproj`
- `tests/Lemoo.Core.Application.Tests/Common/ResultTests.cs`
- `tests/Lemoo.Core.Application.Tests/ErrorDetailTests.cs`

**DevOps**:
- `Dockerfile`
- `.dockerignore`
- `docker-compose.yml`
- `.github/workflows/build.yml`
- `.github/workflows/codeql.yml`
