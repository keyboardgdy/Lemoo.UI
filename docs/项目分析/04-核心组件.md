# Lemoo.UI 核心组件

## 1. CQRS 系统

### 1.1 命令 (Command)

命令表示改变系统状态的操作。

```csharp
/// <summary>
/// 命令标记接口
/// </summary>
public interface ICommand { }

/// <summary>
/// 带返回值的命令接口
/// </summary>
public interface ICommand<TResult> : ICommand, IRequest<TResult> { }
```

**命令示例**:
```csharp
public record CreateTaskCommand(
    string Title,
    string Description,
    TaskPriority Priority,
    DateTime DueDate) : ICommand<Result<Guid>>;
```

### 1.2 查询 (Query)

查询表示读取系统数据的操作，不会改变状态。

```csharp
/// <summary>
/// 查询标记接口
/// </summary>
public interface IQuery { }

/// <summary>
/// 带返回值的查询接口
/// </summary>
public interface IQuery<TResult> : IQuery, IRequest<TResult> { }
```

**查询示例**:
```csharp
public record GetTaskQuery(Guid Id) : IQuery<Result<TaskDto>>;

public record GetAllTasksQuery(
    int PageNumber = 1,
    int PageSize = 10,
    TaskStatus? Status = null) : IQuery<Result<PagedResult<TaskDto>>>;
```

### 1.3 处理器 (Handler)

处理器实现命令和查询的业务逻辑。

```csharp
// 命令处理器
public interface ICommandHandler<TCommand, TResult>
    : IRequestHandler<TCommand, TResult>
    where TCommand : ICommand<TResult>
{
}

// 查询处理器
public interface IQueryHandler<TQuery, TResult>
    : IRequestHandler<TQuery, TResult>
    where TQuery : IQuery<TResult>
{
}
```

**处理器示例**:
```csharp
public class CreateTaskCommandHandler : ICommandHandler<CreateTaskCommand, Result<Guid>>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly ITaskRepository _taskRepository;

    public CreateTaskCommandHandler(
        IUnitOfWork unitOfWork,
        ITaskRepository taskRepository)
    {
        _unitOfWork = unitOfWork;
        _taskRepository = taskRepository;
    }

    public async Task<Result<Guid>> Handle(
        CreateTaskCommand request,
        CancellationToken cancellationToken)
    {
        // 1. 创建聚合根
        var result = Task.Create(
            request.Title,
            request.Description,
            request.Priority,
            request.DueDate);

        if (result.IsFailure)
        {
            return Result.Failure<Guid>(result.Error);
        }

        var task = result.Value;

        // 2. 保存到仓储
        await _taskRepository.AddAsync(task, cancellationToken);
        await _unitOfWork.SaveChangesAsync(cancellationToken);

        // 3. 返回结果
        return Result.Success(task.Id);
    }
}
```

### 1.4 管道行为 (Pipeline Behaviors)

#### ValidationBehavior（验证行为）

```csharp
public class ValidationBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        if (_validators.Any())
        {
            var context = new ValidationContext<TRequest>(request);
            var failures = _validators
                .Select(v => v.Validate(context))
                .SelectMany(result => result.Errors)
                .Where(f => f != null)
                .ToList();

            if (failures.Any())
            {
                return CreateValidationResult(failures);
            }
        }

        return await next();
    }
}
```

#### CacheBehavior（缓存行为）

```csharp
public class CacheBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IQuery
{
    private readonly ICacheService _cacheService;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        // 检查缓存特性
        var cacheAttribute = typeof(TRequest).GetCustomAttribute<CacheAttribute>();
        if (cacheAttribute == null)
        {
            return await next();
        }

        // 生成缓存键
        var cacheKey = GenerateCacheKey(request);

        // 尝试从缓存获取
        var cachedResult = await _cacheService.GetAsync<TResponse>(cacheKey);
        if (cachedResult != null)
        {
            return cachedResult;
        }

        // 执行查询
        var result = await next();

        // 缓存结果
        await _cacheService.SetAsync(cacheKey, result, cacheAttribute.Duration);

        return result;
    }
}
```

#### TransactionBehavior（事务行为）

```csharp
public class TransactionBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICommand
{
    private readonly IUnitOfWork _unitOfWork;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        // 开始事务
        await _unitOfWork.BeginTransactionAsync(cancellationToken);

        try
        {
            // 执行处理
            var result = await next();

            // 提交事务
            await _unitOfWork.CommitTransactionAsync(cancellationToken);

            return result;
        }
        catch
        {
            // 回滚事务
            await _unitOfWork.RollbackTransactionAsync(cancellationToken);
            throw;
        }
    }
}
```

#### LoggingBehavior（日志行为）

```csharp
public class LoggingBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        var stopwatch = Stopwatch.StartNew();

        _logger.LogInformation("Handling {RequestName}", requestName);

        try
        {
            var response = await next();
            stopwatch.Stop();

            _logger.LogInformation(
                "Handled {RequestName} in {ElapsedMilliseconds}ms",
                requestName,
                stopwatch.ElapsedMilliseconds);

            return response;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Error handling {RequestName} after {ElapsedMilliseconds}ms",
                requestName,
                stopwatch.ElapsedMilliseconds);
            throw;
        }
    }
}
```

## 2. 结果模式 (Result Pattern)

### 2.1 无返回值结果

```csharp
public record Result
{
    public bool IsSuccess { get; }
    public bool IsFailure => !IsSuccess;
    public string? Error { get; }

    protected Result(bool isSuccess, string? error)
    {
        if (isSuccess && error != null)
            throw new InvalidOperationException();

        if (!isSuccess && error == null)
            throw new InvalidOperationException();

        IsSuccess = isSuccess;
        Error = error;
    }

    public static Result Success() => new(true, null);
    public static Result Failure(string error) => new(false, error);

    // 函数式编程方法
    public Result OnSuccess(Action action)
    {
        if (IsSuccess) action();
        return this;
    }

    public Result OnFailure(Action<string> action)
    {
        if (IsFailure) action(Error!);
        return this;
    }

    public TResult Match<TResult>(
        Func<TResult> onSuccess,
        Func<string, TResult> onFailure)
    {
        return IsSuccess ? onSuccess() : onFailure(Error!);
    }
}
```

### 2.2 有返回值结果

```csharp
public record Result<T> : Result
{
    public T? Value { get; }

    protected Result(bool isSuccess, T? value, string? error)
        : base(isSuccess, error)
    {
        if (isSuccess && value == null)
            throw new InvalidOperationException();

        Value = value;
    }

    public static Result<T> Success(T value) => new(true, value, null);
    public static new Result<T> Failure(string error) => new(false, default, error);

    // 函数式编程方法
    public Result<T> OnSuccess(Action<T> action)
    {
        if (IsSuccess) action(Value!);
        return this;
    }

    public Result<T> OnFailure(Action<string> action)
    {
        if (IsFailure) action(Error!);
        return this;
    }

    public Result<TResult> Map<TResult>(Func<T, TResult> mapper)
    {
        return IsSuccess
            ? Result<TResult>.Success(mapper(Value!))
            : Result<TResult>.Failure(Error!);
    }

    public async Task<Result<TResult>> Bind<TResult>(Func<T, Task<Result<TResult>>> binder)
    {
        return IsSuccess
            ? await binder(Value!)
            : Result<TResult>.Failure(Error!);
    }

    public TResult Match<TResult>(
        Func<T, TResult> onSuccess,
        Func<string, TResult> onFailure)
    {
        return IsSuccess ? onSuccess(Value!) : onFailure(Error!);
    }
}
```

### 2.3 使用示例

```csharp
// 创建结果
var result = Task.Create("标题", "描述", TaskPriority.High, DateTime.UtcNow);

// 链式操作
result.OnSuccess(task => Console.WriteLine($"Created: {task.Id}"))
      .OnFailure(error => Console.WriteLine($"Error: {error}"));

// 映射
var idResult = result.Map(task => task.Id);

// 绑定（异步）
var finalResult = await result.Bind(async task =>
{
    return await ValidateAsync(task);
});

// 模式匹配
var message = result.Match(
    onSuccess: task => $"Task created: {task.Title}",
    onFailure: error => $"Error: {error}");
```

## 3. 仓储模式 (Repository Pattern)

### 3.1 仓储接口

```csharp
public interface IRepository<TEntity, TKey>
    where TEntity : EntityBase<TKey>
{
    // 获取
    Task<TEntity?> GetByIdAsync(TKey id, CancellationToken cancellationToken = default);
    Task<TEntity?> FirstOrDefaultAsync(
        Expression<Func<TEntity, bool>> predicate,
        CancellationToken cancellationToken = default);
    Task<List<TEntity>> GetAllAsync(CancellationToken cancellationToken = default);

    // 查询
    Task<List<TEntity>> FindAsync(
        Expression<Func<TEntity, bool>> predicate,
        CancellationToken cancellationToken = default);
    Task<PagedResult<TEntity>> GetPagedAsync(
        int pageNumber,
        int pageSize,
        Expression<Func<TEntity, bool>>? predicate = null,
        CancellationToken cancellationToken = default);

    // 添加
    Task AddAsync(TEntity entity, CancellationToken cancellationToken = default);
    Task AddRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken = default);

    // 更新
    void Update(TEntity entity);

    // 删除
    void Delete(TEntity entity);
    void DeleteRange(IEnumerable<TEntity> entities);

    // 计数
    Task<int> CountAsync(CancellationToken cancellationToken = default);
    Task<int> CountAsync(
        Expression<Func<TEntity, bool>> predicate,
        CancellationToken cancellationToken = default);

    // 存在
    Task<bool> AnyAsync(CancellationToken cancellationToken = default);
    Task<bool> AnyAsync(
        Expression<Func<TEntity, bool>> predicate,
        CancellationToken cancellationToken = default);
}
```

### 3.2 只读仓储接口

```csharp
public interface IReadOnlyRepository<TEntity, TKey>
    where TEntity : EntityBase<TKey>
{
    Task<TEntity?> GetByIdAsync(TKey id, CancellationToken cancellationToken = default);
    Task<List<TEntity>> GetAllAsync(CancellationToken cancellationToken = default);
    Task<List<TEntity>> FindAsync(
        Expression<Func<TEntity, bool>> predicate,
        CancellationToken cancellationToken = default);
    Task<PagedResult<TEntity>> GetPagedAsync(
        int pageNumber,
        int pageSize,
        Expression<Func<TEntity, bool>>? predicate = null,
        CancellationToken cancellationToken = default);
    Task<int> CountAsync(CancellationToken cancellationToken = default);
    Task<bool> AnyAsync(CancellationToken cancellationToken = default);
}
```

### 3.3 仓储实现

```csharp
public class Repository<TEntity, TKey> : IRepository<TEntity, TKey>
    where TEntity : EntityBase<TKey>
{
    private readonly DbSet<TEntity> _dbSet;

    public Repository(DbContext context)
    {
        _dbSet = context.Set<TEntity>();
    }

    public async Task<TEntity?> GetByIdAsync(TKey id, CancellationToken cancellationToken = default)
    {
        return await _dbSet.FindAsync(new object[] { id! }, cancellationToken);
    }

    public async Task<List<TEntity>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.ToListAsync(cancellationToken);
    }

    public async Task<List<TEntity>> FindAsync(
        Expression<Func<TEntity, bool>> predicate,
        CancellationToken cancellationToken = default)
    {
        return await _dbSet.Where(predicate).ToListAsync(cancellationToken);
    }

    public async Task<PagedResult<TEntity>> GetPagedAsync(
        int pageNumber,
        int pageSize,
        Expression<Func<TEntity, bool>>? predicate = null,
        CancellationToken cancellationToken = default)
    {
        var query = predicate != null ? _dbSet.Where(predicate) : _dbSet;

        var totalCount = await query.CountAsync(cancellationToken);
        var items = await query
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(cancellationToken);

        return new PagedResult<TEntity>(items, totalCount, pageNumber, pageSize);
    }

    public async Task AddAsync(TEntity entity, CancellationToken cancellationToken = default)
    {
        await _dbSet.AddAsync(entity, cancellationToken);
    }

    public void Update(TEntity entity)
    {
        _dbSet.Update(entity);
    }

    public void Delete(TEntity entity)
    {
        _dbSet.Remove(entity);
    }

    public async Task<int> CountAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.CountAsync(cancellationToken);
    }

    public async Task<bool> AnyAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.AnyAsync(cancellationToken);
    }
}
```

## 4. 工作单元模式 (Unit of Work Pattern)

### 4.1 工作单元接口

```csharp
public interface IUnitOfWork
{
    // 开始事务
    Task BeginTransactionAsync(CancellationToken cancellationToken = default);

    // 提交事务
    Task CommitTransactionAsync(CancellationToken cancellationToken = default);

    // 回滚事务
    Task RollbackTransactionAsync(CancellationToken cancellationToken = default);

    // 保存更改
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
}
```

### 4.2 工作单元实现

```csharp
public class UnitOfWork : IUnitOfWork
{
    private readonly DbContext _context;
    private IDbContextTransaction? _transaction;

    public UnitOfWork(DbContext context)
    {
        _context = context;
    }

    public async Task BeginTransactionAsync(CancellationToken cancellationToken = default)
    {
        _transaction = await _context.Database.BeginTransactionAsync(cancellationToken);
    }

    public async Task CommitTransactionAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            await _context.SaveChangesAsync(cancellationToken);
            if (_transaction != null)
            {
                await _transaction.CommitAsync(cancellationToken);
            }
        }
        catch
        {
            await RollbackTransactionAsync(cancellationToken);
            throw;
        }
        finally
        {
            if (_transaction != null)
            {
                await _transaction.DisposeAsync();
                _transaction = null;
            }
        }
    }

    public async Task RollbackTransactionAsync(CancellationToken cancellationToken = default)
    {
        if (_transaction != null)
        {
            await _transaction.RollbackAsync(cancellationToken);
            await _transaction.DisposeAsync();
            _transaction = null;
        }
    }

    public async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        return await _context.SaveChangesAsync(cancellationToken);
    }
}
```

## 5. 领域事件系统

### 5.1 领域事件接口

```csharp
public interface IDomainEvent
{
    DateTime OccurredOn { get; }
}

public interface IDomainEventHandler<TEvent>
    where TEvent : IDomainEvent
{
    Task Handle(TEvent domainEvent, CancellationToken cancellationToken = default);
}
```

### 5.2 领域事件基类

```csharp
public abstract class DomainEventBase : IDomainEvent
{
    public DateTime OccurredOn { get; }

    protected DomainEventBase()
    {
        OccurredOn = DateTime.UtcNow;
    }
}
```

### 5.3 聚合根基类（支持领域事件）

```csharp
public abstract class AggregateRoot<TKey> : EntityBase<TKey>
{
    private readonly List<IDomainEvent> _domainEvents = new();

    public IReadOnlyCollection<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public void RemoveDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Remove(domainEvent);
    }

    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }
}
```

### 5.4 使用示例

```csharp
// 定义领域事件
public record TaskCreatedEvent(Guid TaskId, string Title) : DomainEventBase;

// 在聚合根中发布事件
public class Task : AggregateRoot<Guid>
{
    public static Result<Task> Create(string title, string description)
    {
        var task = new Task
        {
            Id = Guid.NewGuid(),
            Title = title,
            Description = description
        };

        // 添加领域事件
        task.AddDomainEvent(new TaskCreatedEvent(task.Id, task.Title));

        return Result.Success(task);
    }
}

// 定义事件处理器
public class TaskCreatedEventHandler : IDomainEventHandler<TaskCreatedEvent>
{
    private readonly INotificationService _notificationService;

    public TaskCreatedEventHandler(INotificationService notificationService)
    {
        _notificationService = notificationService;
    }

    public async Task Handle(
        TaskCreatedEvent domainEvent,
        CancellationToken cancellationToken)
    {
        await _notificationService.SendAsync(
            $"Task '{domainEvent.Title}' has been created.");
    }
}
```

## 6. 缓存系统

### 6.1 缓存接口

```csharp
public interface ICacheService
{
    Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default);
    Task SetAsync<T>(
        string key,
        T value,
        TimeSpan? expiration = null,
        CancellationToken cancellationToken = default);
    Task RemoveAsync(string key, CancellationToken cancellationToken = default);
    Task<bool> ExistsAsync(string key, CancellationToken cancellationToken = default);
}
```

### 6.2 内存缓存实现

```csharp
public class MemoryCacheService : ICacheService
{
    private readonly IMemoryCache _cache;

    public MemoryCacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default)
    {
        _cache.TryGetValue(key, out var value);
        return Task.FromResult(value is T typedValue ? typedValue : default);
    }

    public Task SetAsync<T>(
        string key,
        T value,
        TimeSpan? expiration = null,
        CancellationToken cancellationToken = default)
    {
        var options = new MemoryCacheEntryOptions();
        if (expiration.HasValue)
        {
            options.SetAbsoluteExpiration(expiration.Value);
        }

        _cache.Set(key, value, options);
        return Task.CompletedTask;
    }

    public Task RemoveAsync(string key, CancellationToken cancellationToken = default)
    {
        _cache.Remove(key);
        return Task.CompletedTask;
    }

    public Task<bool> ExistsAsync(string key, CancellationToken cancellationToken = default)
    {
        return Task.FromResult(_cache.TryGetValue(key, out _));
    }
}
```

### 6.3 缓存特性

```csharp
[AttributeUsage(AttributeTargets.Class)]
public class CacheAttribute : Attribute
{
    public TimeSpan Duration { get; }

    public CacheAttribute(int minutes)
    {
        Duration = TimeSpan.FromMinutes(minutes);
    }
}
```

### 6.4 使用示例

```csharp
// 应用缓存特性
[Cache(10)] // 缓存 10 分钟
public record GetAllTasksQuery() : IQuery<Result<List<TaskDto>>>;

// 手动使用缓存
public class TaskService
{
    private readonly ICacheService _cacheService;

    public async Task<List<TaskDto>> GetAllTasksAsync()
    {
        var cacheKey = "tasks:all";

        var cachedTasks = await _cacheService.GetAsync<List<TaskDto>>(cacheKey);
        if (cachedTasks != null)
        {
            return cachedTasks;
        }

        var tasks = await _repository.GetAllAsync();
        var dtos = tasks.Select(MapToDto).ToList();

        await _cacheService.SetAsync(cacheKey, dtos, TimeSpan.FromMinutes(10));

        return dtos;
    }
}
```

## 7. 日志系统

### 7.1 日志服务

```csharp
public interface ILoggerService
{
    void LogInformation(string message, params object[] args);
    void LogWarning(string message, params object[] args);
    void LogError(Exception exception, string message, params object[] args);
}

public class LoggerService<T> : ILoggerService
{
    private readonly ILogger<T> _logger;

    public LoggerService(ILogger<T> logger)
    {
        _logger = logger;
    }

    public void LogInformation(string message, params object[] args)
    {
        _logger.LogInformation(message, args);
    }

    public void LogWarning(string message, params object[] args)
    {
        _logger.LogWarning(message, args);
    }

    public void LogError(Exception exception, string message, params object[] args)
    {
        _logger.LogError(exception, message, args);
    }
}
```

### 7.2 Serilog 配置

```csharp
public static class SerilogConfiguration
{
    public static void ConfigureSerilog(
        HostBuilderContext context,
        IServiceProvider provider,
        LoggerConfiguration configuration)
    {
        configuration
            .ReadFrom.Configuration(context.Configuration)
            .ReadFrom.Services(provider)
            .Enrich.FromLogContext()
            .Enrich.WithProperty("Application", "Lemoo.UI")
            .WriteTo.Console()
            .WriteTo.File(
                "logs/log-.txt",
                rollingInterval: RollingInterval.Day,
                outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}");
    }
}
```

### 7.3 性能指标

```csharp
public class PerformanceMetrics
{
    private readonly ILogger<PerformanceMetrics> _logger;
    private readonly ILoggerService _loggerService;

    public PerformanceMetrics(
        ILogger<PerformanceMetrics> logger,
        ILoggerService loggerService)
    {
        _logger = logger;
        _loggerService = loggerService;
    }

    public IDisposable MeasureOperation(string operationName)
    {
        return new OperationTimer(_logger, operationName);
    }

    private class OperationTimer : IDisposable
    {
        private readonly ILogger _logger;
        private readonly string _operationName;
        private readonly Stopwatch _stopwatch;

        public OperationTimer(ILogger logger, string operationName)
        {
            _logger = logger;
            _operationName = operationName;
            _stopwatch = Stopwatch.StartNew();
        }

        public void Dispose()
        {
            _stopwatch.Stop();
            _logger.LogInformation(
                "Operation {OperationName} completed in {ElapsedMilliseconds}ms",
                _operationName,
                _stopwatch.ElapsedMilliseconds);
        }
    }
}
```
